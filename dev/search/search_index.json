{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"community/index.html","title":"Community","text":"<p>Welcome to the Dynamiqs community! You can get involved in the project by:</p> <ul> <li>Opening issues in the GitHub repository, see GitHub Issues.</li> <li>Contributing to the codebase, see Contributing.</li> <li>Reaching out to us, see Let's talk.</li> <li>Joining the Dynamiqs community on Slack.</li> <li>Citing Dynamiqs in your research, see Citing Dynamiqs.</li> </ul> <p>We always welcome issue raisers, contributors, and quantum physics lovers. Come and help us make Dynamiqs better!</p>"},{"location":"community/citing.html","title":"Citing Dynamiqs","text":"<p>If you have found this library useful in your academic research, you can cite:</p> <pre><code>@unpublished{guilmin2024dynamiqs,\n  title  = {Dynamiqs: an open-source Python library for GPU-accelerated and differentiable simulation of quantum systems},\n  author = {Pierre Guilmin and Ronan Gautier and Adrien Bocquet and {\\'{E}}lie Genois},\n  year   = {2024},\n  url    = {https://github.com/dynamiqs/dynamiqs}\n}\n</code></pre> <p>P. Guilmin, R. Gautier, A. Bocquet, E. Genois. Dynamiqs: an open-source Python library for GPU-accelerated and differentiable simulation of quantum systems (2024), in preparation.</p>"},{"location":"community/contributing.html","title":"Contributing to Dynamiqs","text":"<p>We warmly welcome all contributions. If you're a junior developer or physicist, you can start with a small utility function, and move on to bigger problems as you discover the library's internals. If you're more experienced and want to implement more advanced features, don't hesitate to get in touch to discuss what would suit you.</p> <p>To contribute efficiently, a few guidelines are compiled below.</p>"},{"location":"community/contributing.html#requirements","title":"Requirements","text":"<p>The project was written using Python 3.9+, you must have a compatible version of Python (i.e. &gt;= 3.9) installed on your computer.</p>"},{"location":"community/contributing.html#setup","title":"Setup","text":"<p>Clone the repository and dive in:</p> <pre><code>git clone git@github.com:dynamiqs/dynamiqs.git\ncd dynamiqs\n</code></pre> <p>We strongly recommend that you create a virtual environment to install the project dependencies. You can then install the library (in editable mode) with all its dependencies:</p> <pre><code>pip install -e .\n</code></pre> <p>You also need to install the developer dependencies:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"community/contributing.html#code-style","title":"Code style","text":"<p>This project follows PEP8 and uses automatic formatting and linting tools to ensure that the code is compliant.</p> <p>The maximum line length is 88, we recommend that you set this limit in your IDE.</p>"},{"location":"community/contributing.html#workflow","title":"Workflow","text":""},{"location":"community/contributing.html#before-submitting-a-pull-request-run-all-tasks","title":"Before submitting a pull request (run all tasks)","text":"<p>Run all tasks before each commit:</p> <pre><code>task all\n</code></pre>"},{"location":"community/contributing.html#run-some-tasks-automatically-before-each-commit","title":"Run some tasks automatically before each commit","text":"<p>Alternatively, you can use <code>pre-commit</code> to automatically run the cleaning tasks (ruff + codespell) before each commit:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"community/contributing.html#build-the-documentation","title":"Build the documentation","text":"<p>The documentation is built using MkDocs and the Material for MkDocs theme. MkDocs generates a static website based on the markdown files in the <code>docs/</code> directory.</p> <p>To preview the changes to the documentation as you edit the docstrings or the markdown files in <code>docs/</code>, we recommend starting a live preview server, which will automatically rebuild the website upon modifications:</p> <pre><code>task docserve\n</code></pre> <p>Open http://localhost:8000/ in your web browser to preview the documentation website.</p> <p>You can build the static documentation website locally with:</p> <pre><code>task docbuild\n</code></pre> <p>This will create a <code>site/</code> directory with the contents of the documentation website. You can then simply open <code>site/index.html</code> in your web browser to view the documentation website.</p>"},{"location":"community/contributing.html#run-specific-tasks","title":"Run specific tasks","text":"<p>You can also execute tasks individually:</p> <pre><code>&gt; task --list\nlint         lint the code (ruff)\nformat       auto-format the code (ruff)\ncodespell    check for misspellings (codespell)\nclean        clean the code (ruff + codespell)\ntest         run the unit tests suite (pytest)\ndoctest-code check code docstrings examples (doctest)\ndoctest-docs check documentation examples (doctest)\ndoctest      check all examples (doctest)\ndocbuild     build the documentation website\ndocserve     preview documentation website with hot-reloading\nall          run all tasks before a commit (ruff + codespell + pytest + doctest)\nci           run all the CI checks\n</code></pre>"},{"location":"community/lets-talk.html","title":"Let's talk!","text":"<p>If you're curious, have questions or suggestions, wish to contribute or simply want to say hello, please don't hesitate to engage with us, we're always happy to chat! You can join the community on Slack via this invite link, open an issue on GitHub, or contact the lead developer via email at pierreguilmin@gmail.com.</p>"},{"location":"documentation/index.html","title":"Documentation","text":"<p>Welcome to the Dynamiqs documentation! This page will guide you through learning Dynamiqs, from installation and basic examples to advanced tutorials. You can also find a list of available functions and classes in the Python API.</p>"},{"location":"documentation/index.html#getting-started","title":"Getting started","text":"<p>First time using Dynamiqs? Get to know the library and run your first simulations.</p> <ul> <li>What is Dynamiqs?</li> <li>Installation</li> <li>Basic examples</li> <li>The sharp bits \ud83d\udd2a</li> </ul>"},{"location":"documentation/index.html#learn-the-basics","title":"Learn the basics","text":"<p>Familiarize yourself with Dynamiqs. Learn how to simulate quantum systems, define time-dependent operators, run multiple simulations concurrently, and compute gradients.</p> <ul> <li>Workflow in Dynamiqs</li> <li>Time-dependent operators</li> <li>Closed systems</li> <li>Open systems</li> <li>Batching simulations</li> <li>Computing gradients</li> </ul>"},{"location":"documentation/index.html#advanced-examples","title":"Advanced examples","text":"<p>Explore advanced examples and tutorials to deepen your understanding of Dynamiqs.</p> <ul> <li>Driven-dissipative Kerr oscillator</li> </ul>"},{"location":"documentation/advanced_examples/kerr-oscillator.html","title":"Driven-dissipative Kerr oscillator","text":"<p>In this example, we show how to simulate a driven-dissipative Kerr oscillator in Dynamiqs. It is a simple example of a non-linear quantum harmonic oscillator with dissipative coupling to its environment. In the appropriate rotating frame, it is described by the master equation $$     \\frac{\\dd\\rho}{\\dt} = -i [H(t), \\rho] + \\kappa \\mathcal{D}[a] (\\rho), $$ with Hamiltonian $$     H(t) = -K a^{\\dagger 2} a^2 + \\epsilon(t) a^\\dagger + \\epsilon^*(t) a, $$ with \\(\\kappa\\) the rate of single-photon dissipation, \\(K\\) the Kerr non-linearity, and \\(\\epsilon(t)\\) the driving field.</p> <pre><code>import dynamiqs as dq\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#basic-time-evolution","title":"Basic time evolution","text":"<p>Let us begin with a simple simulation of the time evolution of this system, assuming that the driving field is constant and the system is initially in a coherent state.</p> <pre><code># simulation parameters\nn = 32         # Hilbert space size\nK = 1.0        # Kerr non-linearity\nepsilon = 3.0  # driving field\nkappa = 1.5    # dissipation rate\nalpha0 = 2.0   # initial coherent state amplitude\nT = 5.0        # simulation time\nntsave = 201   # number of saved states\n\n# operators\na, adag = dq.destroy(n), dq.create(n)\nH = -K * adag @ adag @ a @ a + epsilon * (a + adag)\njump_ops = [jnp.sqrt(kappa) * a]\n\n# initial state\npsi0 = dq.coherent(n, alpha0)\n\n# save times\ntsave = jnp.linspace(0.0, T, ntsave)\n\n# run simulation\nresult = dq.mesolve(H, jump_ops, psi0, tsave)\n</code></pre> <p>From this simulation, we can extract any property of the evolved state at any saved time. We can for instance access the number of photons in the final state using</p> <pre><code>&gt;&gt;&gt; dq.expect(adag @ a, result.states[-1])\nArray(1.434+0.j, dtype=complex64)\n</code></pre> <p>Alternatively, we can also plot the Wigner function of the evolved state.</p> <pre><code>gif = dq.plot.wigner_gif(result.states, ymax=3.0, gif_duration=10.0)\nrendergif(gif, 'wigner-kerr-oscillator')\n</code></pre> <p></p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#periodic-revival-of-a-coherent-state","title":"Periodic revival of a coherent state","text":""},{"location":"documentation/advanced_examples/kerr-oscillator.html#time-evolution-of-the-cavity-field","title":"Time evolution of the cavity field","text":"<p>One of the most striking features of the Kerr oscillator is the periodic revival of the initial coherent state. This phenomenon is a direct consequence of the non-linear interaction between the photons in the cavity. We can observe this effect by plotting the absolute value of the cavity field as a function of time, for a simulation time over several units of Kerr, and as long as photon loss is not too important.</p> <pre><code># simulation parameters\nn = 32\nK = 1.0\nkappa = 0.02\nalpha0 = 2.0\nntsave = 201\n\n# operators\na, adag = dq.destroy(n), dq.create(n)\nH = -K * adag @ adag @ a @ a\njump_ops = [jnp.sqrt(kappa) * a]\n\n# initial state\npsi0 = dq.coherent(n, alpha0)\n\n# save times\nT = 5 * jnp.pi / K\ntsave = jnp.linspace(0.0, T, ntsave)\n\n# expectation operator\nexp_ops = [a]\n\n# run simulation\nresult = dq.mesolve(H, jump_ops, psi0, tsave, exp_ops=exp_ops)\n\n# plot cavity field\nplt.plot(tsave * K / jnp.pi, jnp.abs(result.expects[0]))\nplt.xlabel(r'Time, $tK / \\pi$')\nplt.ylabel(r'$|\\langle a(t) \\rangle|$')\nrenderfig('photon-number-kerr-oscillator')\n</code></pre> <p></p> <p>We indeed observe a periodic revival of the coherent state, with a period of \\(\\pi / K\\). These revivals have a reduced amplitude due to the presence of photon loss.</p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#study-of-revivals","title":"Study of revivals","text":"<p>We can further investigate these periodic revivals by plotting the amplitude of the first revival as a function of the photon loss \\(\\kappa\\), and as a function of the initial coherent state amplitude. To do so, we make use of a powerful feature of Dynamiqs: the ability to batch simulations concurrently. Here, we can batch over both a jump operator and the initial state.</p> <pre><code># parameters to sweep\nkappas = jnp.linspace(0.0, 0.1, 11)\nnbar0s = jnp.linspace(0.4, 4.0, 10)\nalpha0s = jnp.sqrt(nbar0s)\n\n# redefine jump operators and initial states\njump_ops = [jnp.sqrt(kappas[:, None, None]) * a] # using numpy broadcasting\npsi0 = dq.coherent(n, alpha0s) # dq.coherent accepts a batched input\n\n# save times\nT = jnp.pi / K  # a single revival\ntsave = jnp.linspace(0.0, T, 100)\n\n# run batched simulation\nresult = dq.mesolve(H, jump_ops, psi0, tsave, exp_ops=exp_ops)\namp_revivals = jnp.abs(result.expects[:, :, 0, -1] / result.expects[:, :, 0, 0])\n\n# plot a 2D map of the normalized amplitude revivals\ncontour = plt.pcolormesh(nbar0s, kappas / K, amp_revivals)\ncbar = plt.colorbar(contour, label=r'$|\\langle a(T) \\rangle / \\langle a(0) \\rangle |$')\nplt.xlabel(r'Initial coherent state amplitude, $\\bar{n}_0 = |\\alpha_0|^2$')\nplt.ylabel(r'Loss rate, $\\kappa / K$')\nrenderfig('amplitude-revivals-kerr-oscillator')\n</code></pre> <p></p> <p>We observe that the amplitude of the first revival decreases monotically with the photon loss rate \\(\\kappa\\), and with the initial coherent state amplitude \\(\\bar{n}\\). This behavior is consistent with the expected behavior of the Kerr oscillator. Remarkably, thanks to batching, such a set of hundreds of simulations can be run in a few seconds.</p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#the-transmon-regime","title":"The transmon regime","text":"<p>In this section, we investigate the driven-dissipative Kerr oscillator in the transmon regime, where the Kerr non-linearity is much larger than the driving field and the dissipation rate, \\(K \\gg |\\epsilon| \\gg \\kappa\\). In this regime, the two lowest-energy Fock states are frequency-detuned and thus decoupled from the rest of the system, allowing for quantum information processing.</p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#rabi-oscillations","title":"Rabi oscillations","text":"<p>Because this regime describes an effective two-level system, we can observe Rabi oscillations. These can be simulated by constant driving the system initialized in vacuum.</p> <pre><code># simulation parameters\nn = 8\nK = 200.0\nepsilon = 40.0\nkappa = 1.0\nT = 10 * jnp.pi / epsilon\nntsave = 401\n\n# operators\na, adag = dq.destroy(n), dq.create(n)\nH = -K * adag @ adag @ a @ a + epsilon * (a + adag)\njump_ops = [jnp.sqrt(kappa) * a]\n\n# initial state\npsi0 = dq.basis(n, 0)\n\n# save times\ntsave = jnp.linspace(0.0, T, ntsave)\n\n# expectation operator\nexp_ops = [dq.proj(dq.basis(n, 0)), dq.proj(dq.basis(n, 1))]\n\n# run simulation and extract observables\nresult = dq.mesolve(H, jump_ops, psi0, tsave, exp_ops=exp_ops)\npop_0 = result.expects[0].real # population of |0&gt;\npop_1 = result.expects[1].real # population of |1&gt;\n\n# plot Rabi oscillations\nplt.plot(tsave * epsilon / jnp.pi, pop_0, label=r'$|0\\rangle$')\nplt.plot(tsave * epsilon / jnp.pi, pop_1, label=r'$|1\\rangle$')\nplt.plot(tsave * epsilon / jnp.pi, 1 - (pop_0 + pop_1), color='black', label=r'$|2\\rangle$, $|3\\rangle$, $\\ldots$')\nplt.xlabel(r'Time, $t\\epsilon / \\pi$')\nplt.ylabel('Population')\nplt.ylim(0, 1)\nplt.xlim(0, T * epsilon / jnp.pi)\nplt.legend(frameon=True)\nrenderfig('rabi-oscillations-kerr-oscillator')\n</code></pre> <p></p> <p>We indeed find Rabi oscillations between Fock states \\(|0\\rangle\\) and \\(|1\\rangle\\), with a period of \\(\\pi / \\epsilon\\). However, these oscillations are damped due to the presence of photon loss. In addition, we observe that a small fraction of the total population is periodically leaked to higher Fock states. This is because the Kerr oscillator is not a perfect two-level system, and the driving field is too large compared to the Kerr non-linearity.</p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#a-gaussian-pi-pulse","title":"A gaussian pi-pulse","text":"<p>We now study the optimization of a single-qubit gate for this effective two-level system, a crucial step in quantum information processing. More precisely, we aim to find the best parameters to maximize the fidelity of a \\(\\pi\\)-pulse, i.e., a pulse that swaps the populations of the two lowest-energy Fock states. To do so, we need to balance the amplitude damping due to photon loss with the leakage to higher excited states due to finite pulse duration.</p> <p>We define a pulse ansatz and optimize the \\(\\pi\\)-pulse fidelity by sweeping the parameters of this ansatz. The ansatz we study is that of a truncated gaussian, of the form</p> \\[     \\epsilon_{T, \\sigma}(t) = \\frac{\\pi}{2}\\frac{1}{\\sqrt{2\\pi}\\sigma T \\mathrm{erf}\\left(\\frac{1}{2\\sqrt{2} \\sigma}\\right)} \\exp\\left(-\\frac{1}{2}\\frac{(t - T/2)^2}{\\sigma^2 T^2}\\right), \\] <p>where \\(T\\) the gate duration, and \\(\\sigma\\) the normalized pulse width. One can easily check that the pulse area condition is satisfied, i.e.,</p> \\[     2\\int_0^T \\epsilon(t) \\dd t = \\pi. \\] <p>We begin by defining the pulse ansatz: <pre><code>from jax.scipy.special import erf\n\ndef pulse(t, T, sigma):\n    \"\"\"Gaussian pulse ansatz.\"\"\"\n    angle = jnp.pi / 2\n    norm = jnp.sqrt(2 * jnp.pi) * sigma * T * erf(1 / (2 * jnp.sqrt(2) * sigma))\n    gaussian = jnp.exp(-(t - T / 2)**2 / (2 * T**2 * sigma**2))\n    return angle * gaussian / norm\n</code></pre></p> <p>Then, we can define our sweeping parameters, and run the simulation by combining batching over <code>dq.modulated</code> to batch over the pulse width, and a <code>jax.vmap</code> to batch over the gate duration. <pre><code>from functools import partial\n\n# simulation parameters\nn = 8\nK = 200.0\nkappa = 1.0\nntsave = 401\n\n# parameters to sweep\nTs = jnp.linspace(0.05, 0.5, 24)\nsigmas = jnp.linspace(0.05, 0.2, 14)\n\n# operators, initial state, and expectation operator\na, adag = dq.destroy(n), dq.create(n)\nH0 = -K * adag @ adag @ a @ a\njump_ops = [jnp.sqrt(kappa) * a]\npsi0 = dq.basis(n, 0)\nexp_ops = [dq.proj(dq.basis(n, 0)), dq.proj(dq.basis(n, 1))]\n\n@jax.vmap\ndef compute_fidelity(T):\n    \"\"\"Compute the fidelity of a pi-pulse for a given gate duration.\"\"\"\n    # time-dependent Hamiltonian, defined with functools.partial and broadcasting\n    # `f` has signature (t: float) -&gt; Array of shape (len(sigmas),)\n    f = partial(pulse, T=T, sigma=sigmas)\n    H = H0 + dq.modulated(f, a + adag)\n\n    # save times\n    tsave = jnp.linspace(0.0, T, ntsave)\n\n    # run simulation\n    result = dq.mesolve(H, jump_ops, psi0, tsave, exp_ops=exp_ops)\n\n    # fidelity is roughly estimated as the largest overlap with |1&gt;\n    # in a proper study, we would need to compute a full process tomography\n    return jnp.max(result.expects[:, 1, :].real, axis=-1)\n\n# run simulation\nfidelities = compute_fidelity(Ts)\n\n# plot results\nplt.pcolormesh(sigmas, Ts, jnp.log10(1-fidelities), cmap='Blues_r')\nplt.xlabel('Pulse width')\nplt.ylabel('Gate duration')\nplt.colorbar(label='log10(1 - Fidelity)')\nrenderfig('pipulse-kerr-oscillator')\n</code></pre></p> <p></p> <p>We observe that the fidelity of the \\(\\pi\\)-pulse is maximized over a band of pulse widths and gate durations. In practice, one wants to reduce the gate duration as much as possible, but this corresponds to large pulse widths. However, such large-width truncated gaussians are not physical because they do not verify \\(\\epsilon(0) = \\epsilon(T) = 0\\), and similarly for higher derivatives. This is a limitation of our gaussian ansatz, and one would need to consider more complex pulse shapes to optimize this \\(\\pi\\)-pulse in a realistic setting.</p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#optimization-with-grape","title":"Optimization with GRAPE","text":"<p>In this section, we turn to the numerical optimization of the \\(\\pi\\)-pulse using gradient ascent pulse engineering (GRAPE). This method consists of parametrizing the input pulse through a piece-wise constant function, and optimizing each parameter through gradient descent.</p> <p>To do so, we use the <code>optax</code> library for optimization, which provides a simple interface to various gradient descent algorithms. We define a loss function to minimize, which is the negative fidelity of the \\(\\pi\\)-pulse, and a smoothness loss to penalize sharp variations in the pulse. We then run the optimization loop.</p> <pre><code>import optax\n\n# simulation parameters\nn = 8\nK = 200.0\nkappa = 1.0\nT = 0.2\nntsave = 401\n\n# optimization parameters\nntpulse = 101       # number of pieces in the parametrized pulse\nnepochs = 300       # number of optimization epochs\nlearning_rate = 0.2 # gradient descent learning rate\n\n# operators, initial state, and expectation operator\na, adag = dq.destroy(n), dq.create(n)\nH0 = -K * adag @ adag @ a @ a\njump_ops = [jnp.sqrt(kappa) * a]\npsi0 = dq.basis(n, 0)\nexp_ops = [dq.proj(dq.basis(n, 0)), dq.proj(dq.basis(n, 1))]\n\n# save times and pulse times (not necessarely the same)\ntsave = jnp.linspace(0.0, T, ntsave)\ntpulse = jnp.linspace(0.0, T, ntpulse)\n\n# function to optimize\ndef compute_fidelity(amps):\n    # time-dependent Hamiltonian\n    # (sum of two piece-wise constant Hamiltonians and of the static Hamiltonian)\n    Hx = dq.pwc(tpulse, jnp.real(amps), a + adag)\n    Hp = dq.pwc(tpulse, jnp.imag(amps), 1j * (a - adag))\n    H = H0 + Hx + Hp\n\n    # run simulation\n    options = dq.Options(progress_meter=None) # disable progress meter\n    result = dq.mesolve(H, jump_ops, psi0, tsave, exp_ops=exp_ops, options=options)\n\n    # fidelity is now defined as the overlap with |1&gt; at the final time only\n    return result.expects[1, -1].real\n\n# losses to minimize\n@jax.jit\ndef compute_fidelity_loss(amps, weight=1.0):\n    return weight * (1 - compute_fidelity(amps))\n\n@jax.jit\ndef compute_smoothness_loss(amps, weight=1e-4):\n    return weight * jnp.sum(jnp.abs(jnp.diff(jnp.pad(amps, 1)))**2)\n\n# seed amplitudes\namps_seed = 0.5 * jnp.pi / T * jnp.ones(ntpulse - 1) + 1j * jnp.zeros(ntpulse - 1)\n\n# optimization loop\noptimizer = optax.adam(learning_rate)\namps = amps_seed\nopt_state = optimizer.init(amps)\nlosses = []\nfor _ in range(nepochs):\n    # compute losses and their gradients with `jax.value_and_grad`\n    fidelity_loss, fidelity_grad = jax.value_and_grad(compute_fidelity_loss)(amps)\n    smoothness_loss, smoothness_grad = jax.value_and_grad(compute_smoothness_loss)(amps)\n    grads = fidelity_grad + smoothness_grad\n\n    # update amplitudes with optimizer\n    updates, opt_state = optimizer.update(grads.conj(), opt_state)\n    amps = optax.apply_updates(amps, updates)\n\n    # store losses\n    losses.append([fidelity_loss, smoothness_loss])\n\n# plot optimized pulse\ndq.plot.pwc_pulse(tpulse, amps)\nrenderfig('optimized-pulse-kerr-oscillator')\n</code></pre> <p></p> <p>We indeed find a smooth pulse, with a small contribution on the imaginary part corresponding to a drive on the conjugate quadrature. This is typical of an optimal transmon pulse, in which leakage is minimized through this additional drive in a process known as Derivative Removal by Adiabatic Gate (DRAG).</p> <p>We can also plot the evolution of the fidelity and smoothness losses during the optimization process.</p> <pre><code>losses = jnp.asarray(losses)\nplt.plot(losses[:, 0], label=\"Fidelity loss\")\nplt.plot(losses[:, 1], label=\"Smoothness loss\")\nplt.plot(losses[:, 0] + losses[:, 1], c='k', label=\"Total loss\")\nplt.ylim(0)\nplt.xlim(0, nepochs)\nplt.ylabel(\"Loss\")\nplt.xlabel(\"Epoch\")\nplt.legend()\nrenderfig('losses-kerr-oscillator')\n</code></pre> <p></p> <p>We find that the overall loss decreases monotonically, with a smoothness loss kept relatively low compared to the fidelity loss. We also find convergence of the loss function, indicating that the optimization process is successful. Of course, the hyper parameters such as the relative weight of each loss, the number of pulse time steps, the learning rate, or the number of epochs, could be further tuned.</p> <p>For optimal control applications, we also recommend checking out <code>qontrol</code> which is build on top of Dynamiqs, and provides a more advanced interface for pulse optimization.</p>"},{"location":"documentation/basics/batching-simulations.html","title":"Batching simulations","text":"<p>Batching allows running many independent simulations concurrently. It can dramatically speedup simulations, especially on GPUs. In this tutorial, we explain how to batch quantum simulations in Dynamiqs.</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport timeit\n</code></pre>"},{"location":"documentation/basics/batching-simulations.html#batching-in-short","title":"Batching in short","text":"<p>Batching in Dynamiqs is achieved by passing a list of Hamiltonians, initial states, or jump operators to the simulation functions. The result of a batched simulation is a single array that contains all the individual simulations results. For example, let's simulate the Schr\u00f6dinger equation for all combinations of the three Hamiltonians \\(\\{\\sigma_x, \\sigma_y, \\sigma_z\\}\\) and the four initial states \\(\\{\\ket{g}, \\ket{e}, \\ket{+}, \\ket{-}\\}\\):</p> <pre><code># define three Hamiltonians\nH = [dq.sigmax(), dq.sigmay(), dq.sigmaz()]  # (3, 2, 2)\n\n# define four initial states\ng = dq.basis(2, 0)\ne = dq.basis(2, 1)\nplus = dq.unit(g + e)\nminus = dq.unit(g - e)\npsi = [g, e, plus, minus]  # (4, 2, 1)\n\n# run the simulation\ntsave = jnp.linspace(0.0, 1.0, 11)  # (11,)\nresult = dq.sesolve(H, psi, tsave)\nprint(f'Shape of result.states: {result.states.shape}')\n</code></pre> Output<pre><code>Shape of result.states: (3, 4, 11, 2, 1)\n</code></pre> <p>The returned states is an array with shape (3, 4, 11, 2, 1), where 3 is the number of Hamiltonians, 4 is the number of initial states, 11 is the number of saved states, and (2, 1) is the shape of a single state.</p> <p>Note</p> <p>All relevant <code>result</code> attributes are batched. For example if you specified <code>exp_ops</code>, the resulting expectation values <code>result.expects</code> will be an array with shape (3, 4, len(exp_ops), 11).</p> <p>Importantly, batched simulations are not run sequentially in a <code>for</code> loop. What is meant by batching is that instead of evolving from initial to final time a single state with shape (2, 1) for each combination of argument, the whole batched state (3, 4, 2, 1) is evolved once from initial to final time, which is much more efficient.</p>"},{"location":"documentation/basics/batching-simulations.html#batching-modes","title":"Batching modes","text":"<p>There are two ways to batch simulations in Dynamiqs: cartesian batching and flat batching.</p>"},{"location":"documentation/basics/batching-simulations.html#cartesian-batching","title":"Cartesian batching","text":"<p>The simulation runs for all possible combinations of Hamiltonians, jump operators and initial states. This is the default mode.</p> <code>dq.sesolve</code><code>dq.mesolve</code> <p>For <code>dq.sesolve</code>, the returned array has shape: <pre><code>result.states.shape = (...H, ...psi0, ntsave, n, 1)\n</code></pre> where <code>...x</code> indicates the batching shape of <code>x</code>, i.e. its shape without the last two dimensions.</p> <p>Example: Cartesian batching with <code>dq.sesolve</code></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>psi0</code> has shape (4, n, 1),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, 4, ntsave, n, 1).</p> <p>For <code>dq.mesolve</code>, the returned array has shape: <pre><code>result.states.shape = (...H, ...L0, ...L1,  (...), ...rho0, ntsave, n, n)\n</code></pre> where <code>...x</code> indicates the batching shape of <code>x</code>, i.e. its shape without the last two dimensions.</p> <p>Example: Cartesian batching with <code>dq.mesolve</code></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(4, 5, n, n), (6, n, n)],</li> <li><code>rho0</code> has shape (7, n, n),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, 4, 5, 6, 7, ntsave, n, n).</p>"},{"location":"documentation/basics/batching-simulations.html#flat-batching","title":"Flat batching","text":"<p>The simulation runs for each set of Hamiltonians, jump operators and initial states using broadcasting. This mode can be activated by setting <code>cartesian_batching=False</code> in <code>dq.Options</code>. In particular for <code>dq.mesolve()</code>, each jump operator can be batched independently from the others.</p> What is broadcasting? <p>JAX and NumPy broadcasting semantics are very powerful and allow you to write concise and efficient code. For more information, see the NumPy documentation on broadcasting.</p> <code>dq.sesolve</code><code>dq.mesolve</code> <p>For <code>dq.sesolve</code>, the returned array has shape: <pre><code>result.states.shape = (..., ntsave, n, 1)\n</code></pre> where <code>... = jnp.broadcast_shapes(H, psi0)</code> is the broadcasted shape of all arguments.</p> <p>Example: Flat batching with <code>dq.sesolve</code></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>psi0</code> has shape (3, n, 1),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, ntsave, n, 1).</p> <p>For <code>dq.mesolve</code>, the returned array has shape: <pre><code>result.states.shape = (..., ntsave, n, n)\n</code></pre> where <code>... = jnp.broadcast_shapes(H, L0, L1, ..., rho0)</code> is the broadcasted shape of all arguments.</p> <p>Example: Flat batching with <code>dq.mesolve</code></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(3, n, n), (2, 1, n, n)],</li> <li><code>rho0</code> has shape (3, n, n),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, ntsave, n, n).</p> <p>Note</p> <p>Any batch shape is valid as input as long as it is broadcastable with other arguments.</p> <p>For example for <code>dq.sesolve()</code> with <code>H</code> of shape (2, 3, n, n), <code>psi0</code> can be of shape: (n, 1), (3, n, 1), (2, 1, n, 1), (2, 3, n, 1), (..., 2, 3, n, 1), etc. By playing with the arguments shape, you have complete freedom over the simulation you want to run.</p>"},{"location":"documentation/basics/batching-simulations.html#creating-batched-arguments","title":"Creating batched arguments","text":""},{"location":"documentation/basics/batching-simulations.html#single-dimensional-batching","title":"Single-dimensional batching","text":"<p>There are multiple ways to create a batched argument.</p> Using listsUsing JAX broadcastingUsing Dynamiqs functions <p>The most straightforward way is to pass a list of values: <pre><code># define several Hamiltonians\nHx, Hy, Hz = dq.sigmax(), dq.sigmay(), dq.sigmaz()\nH = [Hx, Hy, Hz]  # (3, 2, 2)\n</code></pre></p> <p>It is often useful to sweep a parameter: <pre><code># define several Hamiltonians\nomega = jnp.linspace(0.0, 1.0, 21)\nH = omega[:, None, None] * dq.sigmaz()  # (21, 2, 2)\n</code></pre></p> <p>Or you can use Dynamiqs utility functions directly: <pre><code># define several initial states\nalpha = [1.0, 2.0, 3.0]\npsis = dq.coherent(16, alpha)  # (3, 16, 1)\n</code></pre></p>"},{"location":"documentation/basics/batching-simulations.html#multi-dimensional-batching","title":"Multi-dimensional batching","text":"<p>The previous examples illustrate batching over one dimension, but you can batch over as many dimensions as you want:</p> Using listsUsing JAX broadcastingUsing Dynamiqs functions <pre><code># define several Hamiltonians\nH = [\n    [Hx, 2 * Hx, 3 * Hx, 4 * Hx],\n    [Hy, 2 * Hy, 3 * Hy, 4 * Hy],\n    [Hz, 2 * Hz, 3 * Hz, 4 * Hz]\n]  # (3, 4, 2, 2)\n</code></pre> <pre><code># define several Hamiltonians\nomega = jnp.linspace(0.0, 1.0, 21)[:, None, None, None]\neps = jnp.linspace(0.0, 10.0, 11)[:, None, None]\nH = omega * dq.sigmaz() + eps * dq.sigmaz()  # (21, 11, 2, 2)\n</code></pre> <pre><code># define several initial states\nalpha_real = jnp.linspace(0, 1.0, 5)\nalpha_imag = jnp.linspace(0, 1.0, 6)\nalpha = alpha_real[:, None] + 1j * alpha_imag  # (5, 6)\npsis = dq.coherent(16, alpha)  # (5, 6, 16, 1)\n</code></pre>"},{"location":"documentation/basics/batching-simulations.html#batching-over-a-timearray","title":"Batching over a TimeArray","text":"<p>We have seen how to batch over time-independent objects, but how about time-dependent ones? It's essentialy the same, you have to pass a batched <code>TimeArray</code>, in short:</p> For a <code>PWCTimeArray</code>For a <code>ModulatedTimeArray</code>For a <code>CallableTimeArray</code> <p>The batching of the returned time-array is specified by <code>values</code>. For example, to define a PWC operator batched over a parameter \\(\\theta\\): <pre><code>&gt;&gt;&gt; thetas = jnp.linspace(0.0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; times = [0.0, 1.0, 2.0]\n&gt;&gt;&gt; values = thetas[:, None] * jnp.array([3.0, -2.0])  # (11, 2)\n&gt;&gt;&gt; array = dq.sigmaz()\n&gt;&gt;&gt; H = dq.pwc(times, values, array)\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre></p> <p>The batching of the returned time-array is specified by the array returned by <code>f</code>. For example, to define a modulated Hamiltonian \\(H(t)=\\cos(\\omega t)\\sigma_x\\) batched over the parameter \\(\\omega\\): <pre><code>&gt;&gt;&gt; omegas = jnp.linspace(0.0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; f = lambda t: jnp.cos(omegas * t)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre></p> <p>The batching of the returned time-array is specified by the array returned by <code>f</code>. For example, to define an arbitrary time-dependent operator batched over a parameter \\(\\theta\\): <pre><code>&gt;&gt;&gt; thetas = jnp.linspace(0.0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; f = lambda t: thetas[:, None, None] * jnp.array([[t, 0], [0, 1 - t]])\n&gt;&gt;&gt; H = dq.timecallable(f)\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre></p>"},{"location":"documentation/basics/batching-simulations.html#why-batching","title":"Why batching?","text":"<p>When batching multiple simulations, the state is not a 2-D array that evolves in time but a N-D array which holds all independent simulations. This allows running multiple simulations simultaneously with great efficiency, especially on GPUs. Moreover, it usually simplifies the simulation code and also the subsequent analysis of the results, because they are all gathered in a single large array.</p> <p>Common use cases for batching include:</p> <ul> <li>simulating a system with different values of a parameter (e.g. a drive amplitude),</li> <li>simulating a system with different initial states (e.g. for gate tomography),</li> <li>performing an optimisation using multiple starting points with random initial guesses (for parameters fitting or quantum optimal control).</li> </ul>"},{"location":"documentation/basics/batching-simulations.html#quick-benchmark","title":"Quick benchmark","text":"<p>To illustrate the performance gain of batching, let us compare the total run time between using a for loop vs using a batched simulation. We will simulate a set of 3,000 Hamiltonians on a two-level system:</p> <pre><code># define 3000 Hamiltonians\nomega = jnp.linspace(0.0, 10.0, 100)[:, None, None]\nepsilon = jnp.linspace(0.0, 1.0, 30)[:, None, None, None]\nH = omega * dq.sigmaz() + epsilon * dq.sigmax()  # (100, 30, 2, 2)\n\n# other simulation parameters\npsi0 = dq.basis(2, 0)\ntsave = jnp.linspace(0.0, 1.0, 50)\noptions = dq.Options(progress_meter=None)\n\n# running the simulations successively\ndef run_unbatched():\n    results = []\n    for i in range(len(omega)):\n        for j in range(len(epsilon)):\n            result = dq.sesolve(H[i, j], psi0, tsave, options=options)\n            results.append(result)\n    return results\n\n# running the simulations simultaneously\ndef run_batched():\n    return dq.sesolve(H, psi0, tsave, options=options)\n\n# exclude JIT time from benchmarking by running each function once first\n%timeit -n1 -r1 -q run_unbatched()\n%timeit -n1 -r1 -q run_batched()\n\n# time functions\n%timeit run_unbatched()\n%timeit run_batched()\n</code></pre> Output<pre><code>2.59 s \u00b1 52.8 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n44.1 ms \u00b1 2.66 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</code></pre> <p>As we can see, the batched simulation is much faster than the unbatched one. In this simple example, it is about 60 times faster. The gain in performance will be even more significant for larger simulations, or when using a GPU.</p>"},{"location":"documentation/basics/closed-systems.html","title":"Closed systems","text":"<p>This tutorial introduces the quantum state for a closed quantum system, describes its evolution with the Schr\u00f6dinger equation, and explains two common numerical methods to simulate the evolution: computing the propagator or solving the ODE iteratively.</p>"},{"location":"documentation/basics/closed-systems.html#the-quantum-state","title":"The quantum state","text":"<p>The quantum state that describes a closed quantum system is a state vector \\(\\ket\\psi\\), i.e. a column vector of size \\(n\\)(1): $$     \\ket\\psi=     \\begin{pmatrix}     \\alpha_0\\\\     \\vdots\\\\     \\alpha_{n-1}     \\end{pmatrix}, $$ with \\(\\alpha_0,\\dots,\\alpha_{n-1}\\in\\mathbb{C}\\) and such that \\(\\sum |\\alpha_i|^2=1\\) (the state is a unit vector).</p> <ol> <li>Where \\(n\\) is the dimension of the finite-dimensional complex Hilbert space of the system.</li> </ol> <p>Example for a two-level system</p> <p>For a two-level system, \\(\\ket\\psi=\\begin{pmatrix}\\alpha_0\\\\\\alpha_1\\end{pmatrix}\\) with \\(|\\alpha_0|^2+|\\alpha_1|^2=1\\).</p> <p>Numerically, each coefficient of the state is stored as a complex number represented by two real numbers (the real and the imaginary parts), stored either</p> <ul> <li>in single precision: the <code>complex64</code> type which uses two <code>float32</code>,</li> <li>in double precision: the <code>complex128</code> type which uses two <code>float64</code>.</li> </ul> <p>A greater precision will give a more accurate result, but will also take longer to calculate.</p>"},{"location":"documentation/basics/closed-systems.html#the-schrodinger-equation","title":"The Schr\u00f6dinger equation","text":"<p>The state evolution is described by the Schr\u00f6dinger equation: $$     i\\hbar\\frac{\\dd\\ket{\\psi(t)}}{\\dt}=H\\ket{\\psi(t)}, $$ where \\(H\\) is a linear operator called the Hamiltonian, a matrix of size \\(n\\times n\\). This equation is a first-order (linear and homogeneous) ordinary differential equation (ODE). To simplify notations, we set \\(\\hbar=1\\). In this tutorial we consider a constant Hamiltonian, but note that it can also be time-dependent \\(H(t)\\).</p> <p>Example for a two-level system</p> <p>The Hamiltonian of a two-level system with energy difference \\(\\omega\\) is \\(H=\\frac{\\omega}{2}\\sigma_z=\\begin{pmatrix}\\omega/2&amp;0\\\\0&amp;-\\omega/2\\end{pmatrix}\\).</p>"},{"location":"documentation/basics/closed-systems.html#solving-the-schrodinger-equation-numerically","title":"Solving the Schr\u00f6dinger equation numerically","text":"<p>There are two common ideas for solving the Schr\u00f6dinger equation.</p>"},{"location":"documentation/basics/closed-systems.html#computing-the-propagator","title":"Computing the propagator","text":"<p>The state at time \\(t\\) is given by \\(\\ket{\\psi(t)}=e^{-iHt}\\ket{\\psi(0)}\\), where \\(\\psi(0)\\) is the state at time \\(t=0\\). The operator \\(U(t)=e^{-iHt}\\) is called the propagator, a matrix of size \\(n\\times n\\).</p> Solution for a time-dependent Hamiltonian <p>For a time-dependent Hamiltonian \\(H(t)\\), the solution at time \\(t\\) is $$     \\ket{\\psi(t)} = \\mathscr{T}\\exp\\left(-i\\int_0^tH(t')\\dt'\\right)\\ket{\\psi(0)}, $$ where \\(\\mathscr{T}\\) is the time-ordering symbol, which indicates the time-ordering of the Hamiltonians upon expansion of the matrix exponential (Hamiltonians at different times do not commute).</p> <p>The first idea is to explicitly compute the propagator to evolve the state up to time \\(t\\). There are various ways to compute the matrix exponential, such as exact diagonalization of the Hamiltonian or approximate methods such as truncated Taylor series expansions.</p> <p>Space complexity: \\(O(n^2)\\) (storing the Hamiltonian).</p> <p>Time complexity: \\(O(n^3)\\) (complexity of computing the matrix exponential(1)).</p> <ol> <li>Computing a matrix exponential requires a few matrix multiplications, and the time complexity of multiplying two dense matrices of size \\(n\\times n\\) is \\(\\mathcal{O(n^3)}\\).</li> </ol> <p>Example for a two-level system</p> <p>For \\(H=\\frac{\\omega}{2}\\sigma_z\\), the propagator is straighforward to compute: $$     U(t) = e^{-iHt} = \\begin{pmatrix}e^{-i\\omega t/2} &amp; 0 \\\\ 0 &amp; e^{i\\omega t/2}\\end{pmatrix}. $$</p>"},{"location":"documentation/basics/closed-systems.html#integrating-the-ode","title":"Integrating the ODE","text":"<p>The Schr\u00f6dinger equation is an ODE, for which a wide variety of solvers have been developed. The simplest approach is the Euler method, a first-order ODE solver with a fixed step size which we describe shortly. Let us write the Taylor series expansion of the state at time \\(t+\\dt\\) up to first order: $$     \\begin{aligned}         \\ket{\\psi(t+\\dt)} &amp;= \\ket{\\psi(t)}+\\dt\\frac{\\dd\\ket{\\psi(t)}}{\\dt}+\\mathcal{O}(\\dt^2) \\\\         &amp;\\approx \\ket{\\psi(t)}-iH\\dt\\ket{\\psi(t)},     \\end{aligned} $$ where we used the Schr\u00f6dinger equation to replace the time derivative of the state. By choosing a sufficiently small step size \\(\\dt\\) and starting from \\(\\ket{\\psi(0)}\\), the state is then iteratively evolved to a final time using the previous equation.</p> <p>There are two main types of ODE solvers:</p> <ul> <li>Fixed step size: as with the Euler method, the step size \\(\\dt\\) is fixed during the simulation. The best known higher order methods are the Runge-Kutta methods. It is important for all these methods that the time step is sufficiently small to ensure the accuracy of the solution.</li> <li>Adaptive step size: the step size is automatically adjusted during the simulation, at each time step. A well-known method is the Dormand-Prince method.</li> </ul> <p>Space complexity: \\(O(n^2)\\) (storing the Hamiltonian).</p> <p>Time complexity: \\(O(n^2\\times\\text{number of time steps})\\) (complexity of the matrix-vector product at each time step).</p>"},{"location":"documentation/basics/closed-systems.html#using-dynamiqs","title":"Using Dynamiqs","text":"<p>You can create the state and Hamiltonian using any array-like object. Let's take the example of a two-level system with a simple Hamiltonian:</p> <pre><code>import jax.numpy as jnp\nimport dynamiqs as dq\n\npsi0 = dq.ground()                # initial state\nH = dq.sigmaz()                   # Hamiltonian\ntsave = jnp.linspace(0, 1.0, 11)  # saving times\nres = dq.sesolve(H, psi0, tsave)  # run the simulation\nprint(res.states[-1])             # print the final state\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 2.52ms \u25c6 remaining 0.00ms\nArray([[0.  +0.j   ],\n       [0.54+0.841j]], dtype=complex64)\n</code></pre> <p>If you want to know more about the available solvers or the different options, head to the <code>dq.sesolve()</code> API documentation.</p> <p>You can also directly compute the propagator with the <code>dq.sepropagator()</code> solver. Continuing the last example:</p> <pre><code>res = dq.sepropagator(H, tsave)\nprint(res.propagators[-1])  # print the final propagator\n</code></pre> Output<pre><code>Array([[0.54-0.841j 0.  +0.j   ]\n       [0.  +0.j    0.54+0.841j]], dtype=complex64)\n</code></pre>"},{"location":"documentation/basics/computing-gradients.html","title":"Computing gradients","text":"<p>Work in progress.</p> <p>This tutorial is under construction. In the meantime, you can check out this example that shows how to differentiate an expectation value obtained with <code>dq.mesolve()</code> with respect to simulation parameters.</p>"},{"location":"documentation/basics/open-systems.html","title":"Open systems","text":"<p>This tutorial introduces the quantum state for an open quantum system, describes its evolution with the Lindblad master equation, and explains three common numerical methods to simulate the evolution: computing the propagator, solving the ODE iteratively or sampling trajectories.</p>"},{"location":"documentation/basics/open-systems.html#the-quantum-state","title":"The quantum state","text":"<p>The quantum state that describes an open quantum system is a density matrix \\(\\rho\\). It is a positive semi-definite Hermitian matrix with unit trace, of size \\(n\\times n\\)(1).</p> <ol> <li>Where \\(n\\) is the dimension of the finite-dimensional complex Hilbert space of the system.</li> </ol> <p>Example for a two-level system</p> <p>For a two-level system, \\(\\rho=\\begin{pmatrix}a &amp; b\\\\ c &amp; d\\end{pmatrix}\\) with \\(a,d\\in\\R^+\\) and \\(b,c\\in\\mathbb{C}\\) with \\(b^*=c\\) (Hermitian matrix), \\(a+d=1\\) (unit trace) and all its eigenvalues are positive (positive semi-definite).</p> <p>Numerically, each coefficient of the state is stored as a complex number represented by two real numbers (the real and the imaginary parts), stored either</p> <ul> <li>in single precision: the <code>complex64</code> type which uses two <code>float32</code>,</li> <li>in double precision: the <code>complex128</code> type which uses two <code>float64</code>.</li> </ul> <p>A greater precision will give a more accurate result, but will also take longer to calculate.</p>"},{"location":"documentation/basics/open-systems.html#the-lindblad-master-equation","title":"The Lindblad master equation","text":"<p>The state evolution is described by the Lindblad master equation: $$     \\frac{\\dd\\rho(t)}{\\dt} = -\\frac{i}{\\hbar}[H, \\rho(t)] + \\sum_{k=1}^N \\left(L_k \\rho(t) L_k^\\dag - \\frac{1}{2} L_k^\\dag L_k \\rho(t) - \\frac{1}{2} \\rho(t) L_k^\\dag L_k\\right), $$ where \\(H\\) is a linear operator called the Hamiltonian, a matrix of size \\(n\\times n\\), and \\(\\{L_k\\}\\) is a collection of arbitrary operators called jump operators which are also matrices of size \\(n\\times n\\). This equation is a first-order (linear and homogeneous) ordinary differential equation (ODE). To simplify notations, we set \\(\\hbar=1\\). In this tutorial we consider a constant Hamiltonian and jump operators, but note that they can also be time-dependent \\(H(t)\\) and \\(L_k(t)\\).</p> <p>Example for a two-level system</p> <p>For example, \\(H=\\frac{\\omega}{2}\\sigma_z=\\begin{pmatrix}\\omega/2&amp;0\\\\0&amp;-\\omega/2\\end{pmatrix}\\) and a single jump operator \\(L=\\sqrt\\gamma\\sigma_-=\\begin{pmatrix}0&amp;0\\\\\\sqrt\\gamma&amp;0\\end{pmatrix}\\).</p> <p>We can also write $$     \\frac{\\dd\\rho(t)}{\\dt} = \\mathcal{L}(\\rho(t)), $$ where \\(\\mathcal{L}\\) is a superoperator(1) called the Liouvillian (sometimes referred as Lindbladian). We can write the state and Liouvillian in vectorized form, where we see the state \\(\\rho(t)\\) as a column vector of size \\(n^2\\), and the Liouvillian as a matrix of size \\(n^2\\times n^2\\).</p> <ol> <li>A superoperator is a linear map that takes an operator and returns an operator.</li> </ol> <p>Example for a two-level system</p> <p>For example, for \\(H=\\frac{\\omega}{2}\\sigma_z\\) and a single jump operator \\(L=\\sqrt\\gamma\\sigma_-\\), the Liouvillian in vectorized form is a \\(4\\times4\\) matrix: $$     \\mathcal{L} = \\begin{pmatrix}     -\\gamma &amp; 0 &amp; 0 &amp; 0\\\\     0 &amp; -\\gamma/2+\\omega i &amp; 0 &amp; 0\\\\     0 &amp; 0 &amp; -\\gamma/2-\\omega i &amp; 0\\\\     \\gamma &amp; 0 &amp; 0 &amp; 0\\\\     \\end{pmatrix} $$</p>"},{"location":"documentation/basics/open-systems.html#solving-the-lindblad-master-equation-numerically","title":"Solving the Lindblad master equation numerically","text":"<p>There are three common ideas for solving the Lindblad master equation.</p>"},{"location":"documentation/basics/open-systems.html#computing-the-propagator","title":"Computing the propagator","text":"<p>The state at time \\(t\\) is given by \\(\\rho(t)=e^{t\\mathcal{L}}(\\rho(0))\\), where \\(\\rho(0)\\) is the state at time \\(t=0\\). The superoperator \\(e^{t\\mathcal{L}}\\) is called the propagator, in vectorized form it is a matrix of size \\(n^2\\times n^2\\).</p> Solution for a time-dependent Liouvillian <p>For a time-dependent Liouvillian \\(\\mathcal{L}(t)\\), the solution at time \\(t\\) is $$     \\rho(t) = \\mathscr{T}\\exp\\left(\\int_0^t\\mathcal{L}(t')\\dt'\\right)(\\rho(0)), $$ where \\(\\mathscr{T}\\) is the time-ordering symbol, which indicates the time-ordering of the Liouvillians upon expansion of the matrix exponential (Liouvillians at different times do not commute).</p> <p>The first idea is to explicitly compute the propagator to evolve the state up to time \\(t\\). There are various ways to compute the matrix exponential, such as exact diagonalization of the Liouvillian or approximate methods such as truncated Taylos series expansions.</p> <p>Space complexity: \\(O(n^4)\\) (storing the Liouvillian).</p> <p>Time complexity: \\(O(n^6)\\) (complexity of computing the \\(n^2\\times n^2\\) Liouvillian matrix exponential(1)).</p> <ol> <li>Computing a matrix exponential requires a few matrix multiplications, and the time complexity of multiplying two dense matrices of size \\(n\\times n\\) is \\(\\mathcal{O(n^3)}\\).</li> </ol> <p>For large Hilbert space sizes, the time complexity of computing the matrix exponential is often prohibitive, hence the need for other methods such as the ones we now describe below.</p>"},{"location":"documentation/basics/open-systems.html#integrating-the-ode","title":"Integrating the ODE","text":"<p>The Lindblad master equation is an ODE, for which a wide variety of solvers have been developed. The simplest approach is the Euler method, a first-order ODE solver with a fixed step size which we describe shortly. Let us write the Taylor series expansion of the state at time \\(t+\\dt\\) up to first order: $$     \\begin{aligned}         \\rho(t+\\dt) &amp;= \\rho(t)+\\dt\\frac{\\dd\\rho(t)}{\\dt}+\\mathcal{O}(\\dt^2) \\\\         &amp;\\approx \\rho(t)+\\dt\\mathcal{L}(\\rho(t)) \\\\         &amp;\\approx \\rho(t)+\\dt\\left(-i[H(t), \\rho(t)] + \\sum_{k=1}^N \\left(L_k \\rho(t) L_k^\\dag - \\frac{1}{2} L_k^\\dag L_k \\rho(t) - \\frac{1}{2} \\rho(t) L_k^\\dag L_k\\right)\\right),     \\end{aligned} $$ where we used the Lindblad master equation to replace the time derivative of the state. By choosing a sufficiently small step size \\(\\dt\\) and starting from \\(\\rho(0)\\), the state is then iteratively evolved to a final time using the previous equation.</p> <p>There are two main types of ODE solvers:</p> <ul> <li>Fixed step size: as with the Euler method, the step size \\(\\dt\\) is fixed during the simulation. The best known higher order methods are the Runge-Kutta methods. It is important for all these methods that the time step is sufficiently small to ensure the accuracy of the solution.</li> <li>Adaptive step size: the step size is automatically adjusted during the simulation, at each time step. A well-known method is the Dormand-Prince method.</li> </ul> <p>Space complexity: \\(O(n^2)\\) (storing the Hamiltonian and jump operators).</p> <p>Time complexity: \\(O(n^3\\times\\text{number of time steps})\\) (complexity of the matrix-matrix product at each time step).</p>"},{"location":"documentation/basics/open-systems.html#sampling-trajectories","title":"Sampling trajectories","text":"<p>Also called the quantum-jump approach.</p> <p>Work in progress.</p>"},{"location":"documentation/basics/open-systems.html#using-dynamiqs","title":"Using Dynamiqs","text":"<p>You can create the state, Hamiltonian and jump operators using any array-like object. Let's take the example of a two-level system with a simple Hamiltonian and a single jump operator:</p> <pre><code>import jax.numpy as jnp\nimport dynamiqs as dq\n\npsi0 = dq.excited()                         # initial state\nH = dq.sigmaz()                             # Hamiltonian\njump_ops = [dq.sigmam()]                    # list of jump operators\ntsave = jnp.linspace(0, 1.0, 11)            # saving times\nres = dq.mesolve(H, jump_ops, psi0, tsave)  # run the simulation\nprint(res.states[-1])                       # print the final state\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 4.47ms \u25c6 remaining 0.00ms\nArray([[0.368+0.j, 0.   +0.j],\n       [0.   +0.j, 0.632+0.j]], dtype=complex64)\n</code></pre> <p>If you want to know more about the available solvers or the different options, head to the <code>dq.mesolve()</code> API documentation.</p> <p>You can also directly compute the propagator with the <code>dq.mepropagator()</code> solver. Continuing the last example:</p> <pre><code>res = dq.mepropagator(H, jump_ops, tsave)\nprint(res.propagators[-1])  # print the final propagator\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 2.56ms \u25c6 remaining 0.00ms\nArray([[ 0.368+0.j     0.   +0.j     0.   +0.j     0.   +0.j   ]\n       [ 0.   +0.j    -0.252+0.552j  0.   +0.j     0.   +0.j   ]\n       [ 0.   +0.j     0.   +0.j    -0.252-0.552j  0.   +0.j   ]\n       [ 0.632+0.j     0.   +0.j     0.   +0.j     1.   +0.j   ]], dtype=complex64)\n</code></pre>"},{"location":"documentation/basics/time-dependent-operators.html","title":"Time-dependent operators","text":"<p>This tutorial explains how to define time-dependent Hamiltonians \u2013 and more generally time-dependent operators \u2013 in Dynamiqs. There are currently four supported formats: constant operator, piecewise constant operator, constant operator modulated by a time-dependent factor, or arbitrary time-dependent operator defined by a function.</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\n</code></pre>"},{"location":"documentation/basics/time-dependent-operators.html#the-timearray-type","title":"The <code>TimeArray</code> type","text":"<p>In Dynamiqs, time-dependent operators are defined with <code>TimeArray</code> objects. These objects can be called at arbitrary times, and return the corresponding array at that time. For example to define the Hamiltonian $$     H_x(t)=\\cos(2\\pi t)\\sigma_x $$ <pre><code>&gt;&gt;&gt; f = lambda t: jnp.cos(2.0 * jnp.pi * t)\n&gt;&gt;&gt; Hx = dq.modulated(f, dq.sigmax())  # initialize a modulated time-array\n&gt;&gt;&gt; Hx(1.0)\nArray([[0.+0.j, 1.+0.j],\n       [1.+0.j, 0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; Hx.shape\n(2, 2)\n</code></pre></p> <p>Time-arrays support common arithmetic operations with scalars, regular arrays and other time-array objects. For example to define the Hamiltonian $$     H(t) = \\sigma_z + 2 H_x(t) - \\sin(\\pi t) \\sigma_y $$ <pre><code>&gt;&gt;&gt; g = lambda t: jnp.sin(jnp.pi * t)\n&gt;&gt;&gt; Hy = dq.modulated(g, dq.sigmay())\n&gt;&gt;&gt; H = dq.sigmaz() + 2 * Hx - Hy\n&gt;&gt;&gt; H(1.0)\nArray([[ 1.+0.j,  2.-0.j],\n       [ 2.+0.j, -1.+0.j]], dtype=complex64)\n</code></pre></p> <p>Finally, time-arrays also support common utility functions, such as <code>.conj()</code>, or <code>.reshape()</code>. More details can be found in the <code>TimeArray</code> API page.</p>"},{"location":"documentation/basics/time-dependent-operators.html#defining-a-timearray","title":"Defining a <code>TimeArray</code>","text":""},{"location":"documentation/basics/time-dependent-operators.html#constant-operators","title":"Constant operators","text":"<p>A constant operator is defined by $$     O(t) = O_0 $$ for any time \\(t\\), where \\(O_0\\) is an arbitrary operator. The most practical way to define constant operators is using array-like objects. They can also be instantiated as <code>TimeArray</code> instances using the <code>dq.constant()</code> function. For instance, to define the Pauli operator \\(H = \\sigma_z\\), you can use any of the following syntaxes:</p> DynamiqsNumPy arrayJAX arrayQuTiP QobjPython list <pre><code>import dynamiqs as dq\nH = dq.sigmaz()\n</code></pre> <pre><code>import numpy as np\nH = np.array([[1, 0], [0, -1]])\n</code></pre> <pre><code>import jax.numpy as jnp\nH = jnp.array([[1, 0], [0, -1]])\n</code></pre> <pre><code>import qutip as qt\nH = qt.sigmaz()\n</code></pre> <pre><code>H = [[1, 0], [0, -1]]\n</code></pre> <p>Note</p> <p>Common operators are available as utility functions, see the list of available operators in the Python API.</p>"},{"location":"documentation/basics/time-dependent-operators.html#piecewise-constant-operators","title":"Piecewise constant operators","text":"<p>A piecewise constant (PWC) operator takes constant values over some time intervals. It is defined by $$     O(t) = \\left(\\sum_{k=0}^{N-1} c_k\\; \\Omega_{[t_k, t_{k+1}[}(t)\\right) O_0 $$ where \\(c_k\\) are constant values, \\(\\Omega_{[t_k, t_{k+1}[}\\) is the rectangular window function defined by \\(\\Omega_{[t_a, t_b[}(t) = 1\\) if \\(t \\in [t_a, t_b[\\) and \\(\\Omega_{[t_a, t_b[}(t) = 0\\) otherwise, and \\(O_0\\) is a constant operator.</p> <p>In Dynamiqs, PWC operators are defined by three array-like objects:</p> <ul> <li><code>times</code>: the time points \\((t_0, \\ldots, t_N)\\) defining the boundaries of the time intervals, of shape (N+1,),</li> <li><code>values</code>: the constant values \\((c_0, \\ldots, c_{N-1})\\) for each time interval, of shape (..., N),</li> <li><code>array</code>: the array defining the constant operator \\(O_0\\), of shape (n, n).</li> </ul> <p>To construct a PWC operator, these three arguments must be passed to the <code>dq.pwc()</code> function, which returns a <code>TimeArray</code> object. When called at some time \\(t\\), this object then returns an array with shape (..., n, n). For example, let us define a PWC operator \\(H(t)\\) with constant value \\(3\\sigma_z\\) for \\(t\\in[0, 1[\\) and \\(-2\\sigma_z\\) for \\(t\\in[1, 2[\\): <pre><code>&gt;&gt;&gt; times = [0.0, 1.0, 2.0]\n&gt;&gt;&gt; values = [3.0, -2.0]\n&gt;&gt;&gt; array = dq.sigmaz()\n&gt;&gt;&gt; H = dq.pwc(times, values, array)\n&gt;&gt;&gt; H\nPWCTimeArray(shape=(2, 2), dtype=complex64)\n</code></pre></p> <p>The returned object can be called at different times:</p> \\(t = -1.0\\)\\(t=0.0\\)\\(t=0.5\\)\\(t=1.0\\)\\(t=1.5\\)\\(t=2.0\\) <pre><code>&gt;&gt;&gt; H(-1.0)\nArray([[ 0.+0.j,  0.+0.j],\n       [ 0.+0.j, -0.+0.j]], dtype=complex64)\n</code></pre> <pre><code>&gt;&gt;&gt; H(0.0)\nArray([[ 3.+0.j,  0.+0.j],\n       [ 0.+0.j, -3.+0.j]], dtype=complex64)\n</code></pre> <pre><code>&gt;&gt;&gt; H(0.5)\nArray([[ 3.+0.j,  0.+0.j],\n       [ 0.+0.j, -3.+0.j]], dtype=complex64)\n</code></pre> <pre><code>&gt;&gt;&gt; H(1.0)\nArray([[-2.+0.j, -0.+0.j],\n       [-0.+0.j,  2.-0.j]], dtype=complex64)\n</code></pre> <pre><code>&gt;&gt;&gt; H(1.5)\nArray([[-2.+0.j, -0.+0.j],\n       [-0.+0.j,  2.-0.j]], dtype=complex64)\n</code></pre> <pre><code>&gt;&gt;&gt; H(2.0)\nArray([[ 0.+0.j,  0.+0.j],\n       [ 0.+0.j, -0.+0.j]], dtype=complex64)\n</code></pre> <p>Note</p> <p>The argument <code>times</code> must be sorted in ascending order, but does not need to be evenly spaced. When calling the resulting time-array object at time \\(t\\), the returned array is the operator \\(c_k\\ O_0\\) corresponding to the interval \\([t_k, t_{k+1}[\\) in which the time \\(t\\) falls. If \\(t\\) does not belong to any time intervals, the returned array is null.</p> Batching PWC operators <p>The batching of the returned time-array is specified by <code>values</code>. For example, to define a PWC operator batched over a parameter \\(\\theta\\): <pre><code>&gt;&gt;&gt; thetas = jnp.linspace(0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; times = [0.0, 1.0, 2.0]\n&gt;&gt;&gt; values = thetas[:, None] * jnp.array([3.0, -2.0])  # (11, 2)\n&gt;&gt;&gt; array = dq.sigmaz()\n&gt;&gt;&gt; H = dq.pwc(times, values, array)\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre></p>"},{"location":"documentation/basics/time-dependent-operators.html#modulated-operators","title":"Modulated operators","text":"<p>A modulated operator is defined by $$     O(t) = f(t) O_0 $$ where \\(f(t)\\) is an time-dependent scalar. In Dynamiqs, modulated operators are defined by:</p> <ul> <li><code>f</code>: a Python function with signature <code>f(t: float) -&gt; Scalar | Array</code> that returns the modulating factor \\(f(t)\\) for any time \\(t\\), as a scalar or an array of shape (...),</li> <li><code>array</code>: the array defining the constant operator \\(O_0\\), of shape (n, n).</li> </ul> <p>To construct a modulated operator, these two arguments must be passed to the <code>dq.modulated()</code> function, which returns a <code>TimeArray</code> object. When called at some time \\(t\\), this object then returns an array with shape (..., n, n). For example, let us define the modulated operator \\(H(t)=\\cos(2\\pi t)\\sigma_x\\): <pre><code>&gt;&gt;&gt; f = lambda t: jnp.cos(2.0 * jnp.pi * t)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n&gt;&gt;&gt; H\nModulatedTimeArray(shape=(2, 2), dtype=complex64)\n</code></pre></p> <p>The returned object can be called at different times:</p> \\(t = 0.5\\)\\(t=1.0\\) <pre><code>&gt;&gt;&gt; H(0.5)\nArray([[-0.+0.j, -1.+0.j],\n       [-1.+0.j, -0.+0.j]], dtype=complex64)\n</code></pre> <pre><code>&gt;&gt;&gt; H(1.0)\nArray([[0.+0.j, 1.+0.j],\n       [1.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre> Batching modulated operators <p>The batching of the returned time-array is specified by the array returned by <code>f</code>. For example, to define a modulated Hamiltonian \\(H(t)=\\cos(\\omega t)\\sigma_x\\) batched over the parameter \\(\\omega\\): <pre><code>&gt;&gt;&gt; omegas = jnp.linspace(0.0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; f = lambda t: jnp.cos(omegas * t)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre></p> Function with additional arguments <p>To define a modulated operator with a function that takes arguments other than time (extra <code>*args</code> and <code>**kwargs</code>), you can use <code>functools.partial()</code>. For example: <pre><code>&gt;&gt;&gt; import functools\n&gt;&gt;&gt; def pulse(t, omega, amplitude=1.0):\n...     return amplitude * jnp.cos(omega * t)\n&gt;&gt;&gt; # create function with correct signature (t: float) -&gt; Array\n&gt;&gt;&gt; f = functools.partial(pulse, omega=1.0, amplitude=5.0)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n</code></pre></p> Discontinuous function <p>If there is a discontinuous jump in the function values, you should use the optional argument <code>discontinuity_ts</code> to enforce adaptive step size solvers to stop at these times (i.e., right before, and right after the jump).</p>"},{"location":"documentation/basics/time-dependent-operators.html#arbitrary-time-dependent-operators","title":"Arbitrary time-dependent operators","text":"<p>An arbitrary time-dependent operator is defined by $$     O(t) = f(t) $$ where \\(f(t)\\) is a time-dependent operator. In Dynamiqs, arbitrary time-dependent operators are defined by:</p> <ul> <li><code>f</code>: a Python function with signature <code>f(t: float) -&gt; Array</code> that returns the operator \\(f(t)\\) for any time \\(t\\), as an array of shape (..., n, n).</li> </ul> <p>To construct an arbitrary time-dependent operator, pass this argument to the <code>dq.timecallable()</code> function, which returns a <code>TimeArray</code> object. This object then returns an array with shape (..., n, n) when called at any time \\(t\\).</p> <p>For example, let us define the arbitrary time-dependent operator \\(H(t)=\\begin{pmatrix}t &amp; 0\\\\0 &amp; 1 - t\\end{pmatrix}\\): <pre><code>&gt;&gt;&gt; f = lambda t: jnp.array([[t, 0], [0, 1 - t]])\n&gt;&gt;&gt; H = dq.timecallable(f)\n&gt;&gt;&gt; H\nCallableTimeArray(shape=(2, 2), dtype=float32)\n</code></pre></p> <p>The returned object can be called at different times:</p> \\(t = 0.5\\)\\(t=1.0\\) <pre><code>&gt;&gt;&gt; H(0.5)\nArray([[0.5, 0. ],\n       [0. , 0.5]], dtype=float32)\n</code></pre> <pre><code>&gt;&gt;&gt; H(1.0)\nArray([[1., 0.],\n       [0., 0.]], dtype=float32)\n</code></pre> <p>The function <code>f</code> must return a JAX array (not an array-like object!)</p> <p>An error is raised if the function <code>f</code> does not return a JAX array. This error concerns any other array-like objects. This is enforced to avoid costly conversions at every time step of the numerical integration.</p> Batching arbitrary time-dependent operators <p>The batching of the returned time-array is specified by the array returned by <code>f</code>. For example, to define an arbitrary time-dependent operator batched over a parameter \\(\\theta\\): <pre><code>&gt;&gt;&gt; thetas = jnp.linspace(0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; f = lambda t: thetas[:, None, None] * jnp.array([[t, 0], [0, 1 - t]])\n&gt;&gt;&gt; H = dq.timecallable(f)\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre></p> Function with additional arguments <p>To define an arbitrary time-dependent operator with a function that takes arguments other than time (extra <code>*args</code> and <code>**kwargs</code>), you can use <code>functools.partial()</code>. For example: <pre><code>&gt;&gt;&gt; import functools\n&gt;&gt;&gt; def func(t, a, amplitude=1.0):\n...     return amplitude * jnp.array([[t, a], [a, 1 - t]])\n&gt;&gt;&gt; # create function with correct signature (t: float) -&gt; Array\n&gt;&gt;&gt; f = functools.partial(func, a=1.0, amplitude=5.0)\n&gt;&gt;&gt; H = dq.timecallable(f)\n</code></pre></p> Discontinuous function <p>If there is a discontinuous jump in the function values, you should use the optional argument <code>discontinuity_ts</code> to enforce adaptive step size solvers to stop at these times (i.e., right before, and right after the jump).</p>"},{"location":"documentation/basics/workflow.html","title":"Workflow in Dynamiqs","text":"<p>The core of Dynamiqs is to solve quantum differential equations. This tutorial goes over the basic workflow of such simulations, in mainly four steps:</p> <ul> <li>Define the system: Initialize the state and operators you are interested in.</li> <li>Set the scope: Specify the duration, observables to measure, or solver to use.</li> <li>Run the simulation: Solve the differential equation and collect the results.</li> <li>Analyze the results: Plot results and extract the information you are interested in.</li> </ul> <p>In the rest of this tutorial, we go over these steps in detail, taking the example of Rabi oscillations of a two-level system.</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"documentation/basics/workflow.html#i-define-the-system","title":"I. Define the system","text":"<p>After having imported the necessary packages, we can define our system, namely the initial state, the Hamiltonian, and the eventual loss operators. Common states and operators are already defined in Dynamiqs, see the Python API for more details. Otherwise, you can define specific states and operators using any array-like object.</p> <p>Here, we will use <code>dq.fock()</code> to define the initial state \\(\\ket{\\psi_0}=\\ket{0}\\), <code>dq.sigmaz()</code> and <code>dq.sigmax()</code> to define the Hamiltonian \\(H = \\delta \\sigma_z + \\Omega \\sigma_x\\).</p> <pre><code># initial state\npsi0 = dq.fock(2, 0)\n\n# Hamiltonian\ndelta = 0.3  # detuning\nOmega = 1.0  # Rabi frequency\nH = delta * dq.sigmaz() + Omega * dq.sigmax()\n\nprint(f\"State of type {type(psi0)} and shape {psi0.shape}.\")\nprint(f\"Hamiltonian of type {type(H)} and shape {H.shape}.\")\n</code></pre> Output<pre><code>State of type &lt;class 'jaxlib.xla_extension.ArrayImpl'&gt; and shape (2, 1).\nHamiltonian of type &lt;class 'jaxlib.xla_extension.ArrayImpl'&gt; and shape (2, 2).\n</code></pre> <p>In Dynamiqs, all quantum objects are defined directly with JAX arrays, and without subclassing. This allows for easy interfacing with JAX utility functions, and avoids runtime overheads. Also, all quantum objects have at least two dimensions to avoid systematic reshaping or coding mistakes (e.g. trying to multiply a ket and an operator in the wrong order). In particular, kets have a shape <code>(..., n, 1)</code> and density matrices have shape <code>(..., n, n)</code>.</p>"},{"location":"documentation/basics/workflow.html#ii-set-the-scope","title":"II. Set the scope","text":"<p>Next, we define the scope of the simulation. This includes the total duration of time evolution, the observables we want to measure and how often we measure them. Observables are defined similarly to the Hamiltonian, using arrays and Dynamiqs utility functions. The total duration and how often measurements are performed is defined in a single object named <code>tsave</code>. It is an arbitrary array of time points, of which <code>tsave[-1]</code> specifies the total duration of time evolution.</p> <p>We also need to specify the solver and options related to it, namely the method of integration and the eventual related parameters. The list of available solvers and their parameters is available in the Python API.</p> <pre><code># define sampling times\nsim_time = 10.0  # total time of evolution\nnum_save = 101  # number of time slots to save\ntsave = jnp.linspace(0.0, sim_time, num_save)  # can also be a list or a NumPy array\n\n# define list of observables\nexp_ops = [dq.sigmaz()]  # expectation value of sigma_z\n\n# define solver (Dormand-Prince method of order 5)\nsolver = dq.solver.Dopri5(rtol=1e-6, atol=1e-8)\n</code></pre>"},{"location":"documentation/basics/workflow.html#iii-run-the-simulation","title":"III. Run the simulation","text":"<p>We can now run the simulation. This is done by calling the <code>dq.sesolve()</code> function, which returns an instance of the <code>SESolveResult</code> class. This object contains the computed states, the observables, and various information about the solver.</p> <pre><code># run simulation\nresult = dq.sesolve(H, psi0, tsave, exp_ops=exp_ops, solver=solver)\n\n# print some information\nprint(f\"`result` is of type {type(result)}.\")\nprint(f\"`result` has the following attributes:\")\nprint(f\"{[attr for attr in dir(result) if not attr.startswith('__')]}\\n\")\nprint(result)\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 3.25ms \u25c6 remaining 0.00ms\n`result` is of type &lt;class 'dynamiqs.result.SESolveResult'&gt;.\n`result` has the following attributes:\n['Esave', '_abc_impl', 'expects', 'gradient', 'options', 'solver', 'states', 'to_numpy', 'to_qutip', 'tsave', 'ysave']\n\n==== SESolveResult ====\nSolver  : Dopri5\nInfos   : 56 steps (48 accepted, 8 rejected)\nStates  : Array complex64 (101, 2, 1) | 1.6 Kb\nExpects : Array complex64 (1, 101) | 0.8 Kb\n</code></pre>"},{"location":"documentation/basics/workflow.html#iv-analyze-the-results","title":"IV. Analyze the results","text":"<p>Finally, you can analyze the results in whichever way is most relevant to your application. In our example, let us plot the \\(\\braket{\\sigma_z}\\) observable as a function of time. To do so, we call <code>result.expects[0].real</code> which extracts the first measured observable (here, the only one) and plot its real part (our observable is hermitian, so measurements are real-valued). We compare to the expected analytical result.</p> <pre><code># analytical result\nOmega_star = jnp.sqrt(delta**2 + Omega**2)  # generalized Rabi frequency\nexcited_pop = Omega / Omega_star * jnp.sin(tsave * Omega_star)  # excited population\nsigmaz_analytical = 1 - 2 * excited_pop**2  # expectation value of sigma_z\n\n# plot results\nplt.plot(tsave, sigmaz_analytical, 'k', lw=1.0)\nplt.plot(tsave, result.expects[0].real, 'oC0', ms=4)\n\n# formatting\nplt.xlabel('Time')\nplt.ylabel(r'$\\langle \\sigma_z \\rangle$')\nplt.xlim(0, 10)\nplt.ylim(-1, 1)\nplt.legend(('Analytical', 'Dynamiqs'))\nrenderfig('workflow')\n</code></pre> <p></p> <p>As expected, we find off-resonant Rabi oscillations at the generalized Rabi frequency \\(\\Omega^* = \\sqrt{\\delta^2 + \\Omega^2}\\), and with a reduced amplitude \\(|\\Omega / \\Omega^*|^2\\).</p>"},{"location":"documentation/getting_started/examples.html","title":"Basic examples","text":"<p>First time using Dynamiqs? Below are a few basic examples to help you get started.</p>"},{"location":"documentation/getting_started/examples.html#simulate-a-lossy-quantum-harmonic-oscillator","title":"Simulate a lossy quantum harmonic oscillator","text":"<p>This first example shows simulation of a lossy harmonic oscillator with Hamiltonian \\(H=\\omega a^\\dagger a\\) and a single jump operator \\(L=\\sqrt{\\kappa} a\\) from time \\(0\\) to time \\(T\\), starting from the initial coherent state \\(\\ket{\\alpha_0}\\).</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\n\n# parameters\nn = 16          # Hilbert space dimension\nomega = 1.0     # frequency\nkappa = 0.1     # decay rate\nalpha0 = 1.0    # initial coherent state amplitude\nT = 2 * jnp.pi  # total evolution time (one full revolution)\n\n# initialize operators, initial state and saving times\na = dq.destroy(n)\nH = omega * dq.dag(a) @ a\njump_ops = [jnp.sqrt(kappa) * a]\npsi0 = dq.coherent(n, alpha0)\ntsave = jnp.linspace(0, T, 101)\n\n# run simulation\nresult = dq.mesolve(H, jump_ops, psi0, tsave)\nprint(result)\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 6.30ms \u25c6 remaining 0.00ms\n==== MESolveResult ====\nSolver : Tsit5\nInfos  : 40 steps (40 accepted, 0 rejected)\nStates : Array complex64 (101, 16, 16) | 202.0 Kb\n</code></pre>"},{"location":"documentation/getting_started/examples.html#compute-gradients-with-respect-to-some-parameters","title":"Compute gradients with respect to some parameters","text":"<p>Suppose that in the above example, we want to compute the gradient of the number of photons in the final state at time \\(T\\), \\(\\bar{n} = \\mathrm{Tr}[a^\\dagger a \\rho(T)]\\), with respect to the frequency \\(\\omega\\), the decay rate \\(\\kappa\\) and the initial coherent state amplitude \\(\\alpha_0\\).</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport jax\n\n# parameters\nn = 16          # Hilbert space dimension\nomega = 1.0     # frequency\nkappa = 0.1     # decay rate\nalpha0 = 1.0    # initial coherent state amplitude\nT = 2 * jnp.pi  # total evolution time (one full revolution)\n\ndef population(omega, kappa, alpha0):\n    \"\"\"Return the oscillator population after time evolution.\"\"\"\n    # initialize operators, initial state and saving times\n    a = dq.destroy(n)\n    H = omega * dq.dag(a) @ a\n    jump_ops = [jnp.sqrt(kappa) * a]\n    psi0 = dq.coherent(n, alpha0)\n    tsave = jnp.linspace(0, T, 101)\n\n    # run simulation\n    result = dq.mesolve(H, jump_ops, psi0, tsave)\n\n    return dq.expect(dq.number(n), result.states[-1]).real\n\n# compute gradient with respect to omega, kappa and alpha\ngrad_population = jax.grad(population, argnums=(0, 1, 2))\ngrads = grad_population(omega, kappa, alpha0)\nprint(f'Gradient w.r.t. omega : {grads[0]:.4f}')\nprint(f'Gradient w.r.t. kappa : {grads[1]:.4f}')\nprint(f'Gradient w.r.t. alpha0: {grads[2]:.4f}')\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 5.94ms \u25c6 remaining 0.00ms\nGradient w.r.t. omega : 0.0000\nGradient w.r.t. kappa : -3.3520\nGradient w.r.t. alpha0: 1.0670\n</code></pre> <p>Note</p> <p>On this specific example, we can verify the result analytically. The state remains a coherent state at all time with complex amplitude \\(\\alpha(t) = \\alpha_0 e^{-\\kappa t/2} e^{-i\\omega t}\\), and the final photon number is thus \\(\\bar{n} = |\\alpha(T)|^2 = \\alpha_0^2 e^{-\\kappa T}\\). We can then compute the gradient with respect to the three parameters \\(\\theta = (\\omega, \\kappa, \\alpha_0)\\):</p> \\[ \\nabla_\\theta\\ \\bar{n} = \\begin{pmatrix}   \\partial\\bar{n} / \\partial\\omega \\\\   \\partial\\bar{n} / \\partial\\kappa \\\\   \\partial\\bar{n} / \\partial\\alpha_0 \\end{pmatrix} = \\begin{pmatrix}   0\\\\   -\\alpha_0^2 T e^{-\\kappa T} \\\\   2 \\alpha_0 e^{-\\kappa T} \\end{pmatrix} \\approx \\begin{pmatrix}   0.0 \\\\   -3.3520 \\\\   1.0670 \\end{pmatrix} \\]"},{"location":"documentation/getting_started/installation.html","title":"Installation","text":"<p>You can install Dynamiqs with <code>pip</code>:</p> <pre><code>pip install dynamiqs\n</code></pre> <p>Note</p> <p>If you're using a GPU, please refer to the JAX installation documentation page for detailed instructions on how to install JAX for your device.</p>"},{"location":"documentation/getting_started/sharp-bits.html","title":"The sharp bits \ud83d\udd2a","text":"<p>This page highlight common pitfalls that users may encounter when learning to use Dynamiqs.</p> <pre><code>import dynamiqs as dq\n</code></pre>"},{"location":"documentation/getting_started/sharp-bits.html#main-differences-with-qutip","title":"Main differences with QuTiP","text":"<p>The syntax in Dynamiqs is similar to QuTiP, a popular Python library for quantum simulation. However, there are some important differences that you should be aware of.</p>"},{"location":"documentation/getting_started/sharp-bits.html#floating-point-precision","title":"Floating-point precision","text":"<p>In Dynamiqs, all arrays are represented by default with single-precision floating-point numbers (<code>float32</code> or <code>complex64</code>), whereas the default in QuTiP or NumPy is double-precision (<code>float64</code> or <code>complex128</code>). We made this choice to match JAX's default, and for performance reasons, as many problems do not require double-precision. If needed, it is possible to switch to double-precision using <code>dq.set_precision()</code>: <pre><code>dq.set_precision('double')  # 'simple' by default\n</code></pre></p> <p>When using single-precision, there are certain limitations to be aware of:</p> <ul> <li>Large numbers: Numerical errors in floating-point arithmetic become more significant when using large numbers. Therefore, you should try to choose units for your simulation such that all quantities involved are not too large.</li> <li>Tolerances: If you require very precise simulation results (e.g. if you set lower <code>rtol</code> and <code>atol</code> than the default values), the simulation time may increase significantly, and simulations may even get stuck. In such cases, it is recommended to switch to double-precision.</li> </ul> <p>Warning</p> <p>Most GPUs do not have native support for double-precision, and only perform well in single-precision. However, note that some recent NVIDIA GPUs (e.g. V100, A100, H100) do provide efficient support for double-precision.</p>"},{"location":"documentation/getting_started/sharp-bits.html#adding-a-scalar-to-an-operator","title":"Adding a scalar to an operator","text":"<p>In QuTiP, adding a scalar to a <code>Qobj</code> performs an implicit multiplication of the scalar with the identity matrix. This convention differs from the one adopted by common scientific libraries such as NumPy, PyTorch or JAX. In Dynamiqs, adding a scalar to an array performs an element-wise addition. To achieve the same result as in QuTiP, you must explicitly multiply the scalar with the identity matrix:</p>  Correct Incorrect <pre><code>&gt;&gt;&gt; sz = dq.sigmaz()\n&gt;&gt;&gt; sz - 2 * dq.eye(2)\nArray([[-1.+0.j,  0.+0.j],\n       [ 0.+0.j, -3.+0.j]], dtype=complex64)\n</code></pre> <pre><code>&gt;&gt;&gt; sz = dq.sigmaz()\n&gt;&gt;&gt; sz - 2\nArray([[-1.+0.j, -2.+0.j],\n       [-2.+0.j, -3.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"documentation/getting_started/sharp-bits.html#multiplying-two-operators","title":"Multiplying two operators","text":"<p>In QuTiP, the <code>*</code> symbol is used to multiply two operators. This convention also differs from common scientific libraries. In Dynamiqs, the <code>@</code> symbol is used for matrix multiplication, and the <code>*</code> symbol is reserved for element-wise multiplication:</p>  Correct Incorrect <pre><code>&gt;&gt;&gt; sx = dq.sigmax()\n&gt;&gt;&gt; sx @ sx\nArray([[1.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j]], dtype=complex64)\n</code></pre> <pre><code>&gt;&gt;&gt; sx = dq.sigmax()\n&gt;&gt;&gt; sx * sx\nArray([[0.+0.j, 1.+0.j],\n       [1.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre> <p>Likewise, you should use <code>dq.powm()</code> instead of <code>**</code> (element-wise power) to compute the power of a matrix:</p>  Correct Incorrect <pre><code>&gt;&gt;&gt; dq.powm(sx, 2)\nArray([[1.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j]], dtype=complex64)\n</code></pre> <pre><code>&gt;&gt;&gt; sx**2\nArray([[0.+0.j, 1.+0.j],\n       [1.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"documentation/getting_started/sharp-bits.html#computing-matrix-adjoint","title":"Computing matrix adjoint","text":"<p>Use <code>dq.dag(x)</code> or <code>x.mT.conj()</code> instead of <code>x.dag()</code> to get the hermitian conjugate of <code>x</code>.</p> Why is there no <code>.dag()</code> method in Dynamiqs? <p>To guarantee optimum performances and straightforward compatibility with the JAX ecosystem, Dynamiqs does not subclass JAX arrays. As a consequence, we can't define a custom <code>.dag()</code> method on arrays. Note that this will possibly change in the future, as we are working on an extension that will allow defining custom methods on arrays.</p>"},{"location":"documentation/getting_started/sharp-bits.html#using-a-for-loop","title":"Using a for loop","text":"<p>If you want to simulate multiple Hamiltonians or initial states, you should use batching instead of a <code>for</code> loop. This functionality is explained in detail in the Batching simulations tutorial, together with the associated gain in performance.</p>"},{"location":"documentation/getting_started/whatis.html","title":"What is Dynamiqs ?","text":""},{"location":"documentation/getting_started/whatis.html#in-a-nutshell","title":"In a nutshell","text":"<p>Dynamiqs is a Python library for GPU-accelerated and differentiable quantum simulations. Solvers are available for the Schr\u00f6dinger equation, the Lindblad master equation, and the stochastic master equation. The library is built with JAX and the main solvers are based on Diffrax.</p> <p>See the Python API for a list of available functions and classes.</p> <p>The main features of Dynamiqs are:</p> <ul> <li>Running simulations on CPUs and GPUs with high-performance.</li> <li>Executing many simulations concurrently by batching over Hamiltonians, initial states or jump operators.</li> <li>Computing gradients of arbitrary functions with respect to arbitrary parameters of the system.</li> <li>Full compatibility with the JAX ecosystem with a QuTiP-like API.</li> </ul> <p>We hope that this library will prove useful to the community for e.g. simulation of large quantum systems, gradient-based parameter estimation or quantum optimal control. The library is designed for large-scale problems, but also runs efficiently on CPUs for smaller problems.</p> <p>Warning</p> <p>This library is under active development and while the APIs and solvers are still finding their footing, we're working hard to make it worth the wait. Check back soon for the grand opening!</p>"},{"location":"documentation/getting_started/whatis.html#the-dynamiqs-project","title":"The Dynamiqs project","text":""},{"location":"documentation/getting_started/whatis.html#philosophy","title":"Philosophy","text":"<p>There is a noticeable gap in the availability of an open-source library that simplifies gradient-based parameter estimation and quantum optimal control. In addition, faster simulations of large systems are essential to accelerate the development of quantum technologies. The Dynamiqs library addresses both of these needs. It aims to be a fast and reliable building block for GPU-accelerated and differentiable solvers. We also work to make the library compatible with the existing Python ecosystem (i.e. JAX and QuTiP) to allow easy interfacing with other libraries.</p>"},{"location":"documentation/getting_started/whatis.html#team-and-sponsoring","title":"Team and sponsoring","text":"<p>The library is being developed by a team of physicists and developers. We are working with theorists, experimentalists, machine learning practitioners, optimisation and numerical methods experts to make the library as useful and as powerful as possible. The library is sponsored by the startup Alice &amp; Bob, where it is being used to simulate, calibrate and control chips made of superconducting-based dissipative cat qubits.</p>"},{"location":"documentation/getting_started/whatis.html#history","title":"History","text":"<p>Development started in early 2023, the library was originally based on PyTorch with homemade solvers and gradient methods. It was completely rewritten in JAX in early 2024 for performance.</p>"},{"location":"documentation/getting_started/whatis.html#more-features","title":"More features!","text":"<p>Below are some cool features of Dynamiqs that are either already available or planned for the near future.</p>"},{"location":"documentation/getting_started/whatis.html#solvers","title":"Solvers","text":"<ul> <li>Choose between a variety of solvers, from modern explicit and implicit ODE solvers (e.g. Tsit5 and PID controllers for adaptive step-sizing) to quantum-tailored solvers that preserve the physicality of the evolution (the state trace and positivity are preserved).</li> <li>Simulate time-varying problems (both Hamiltonian and jump operators) with support for various formats (piecewise constant operator, constant operator modulated by a time-dependent factor, etc.).</li> <li>Define a custom save function during the evolution (e.g. to register only the state purity, to track a subsystem by taking the partial trace of the full system, or to compute the population in the last Fock states to regularise your QOC problem).</li> <li>Easily implement your own solvers by subclassing our base solver class and focusing directly on the solver logic.</li> <li>Simulate SME trajectories orders of magnitude faster by batching the simulation over the stochastic trajectories.</li> <li>Use adaptive step-size solvers to solve the SME (based on Brownian bridges to generate the correct statistics).</li> <li>Parallelise large simulations across multiple CPUs/GPUs.</li> </ul>"},{"location":"documentation/getting_started/whatis.html#gradients","title":"Gradients","text":"<ul> <li>Choose between various methods to compute the gradient, to tradeoff speed and memory (e.g. use the optimal online checkpointing scheme of Diffrax to compute gradients for large systems).</li> <li>Compute gradients with machine-precision accuracy.</li> <li>Evaluate derivatives with respect to evolution time (e.g. for time-optimal quantum control).</li> <li>Compute higher order derivatives (e.g. the Hessian).</li> </ul>"},{"location":"documentation/getting_started/whatis.html#utilities","title":"Utilities","text":"<ul> <li>Balance accuracy and speed by choosing between single precision (<code>float32</code> and <code>complex64</code>) or double precision (<code>float64</code> and <code>complex128</code>).</li> <li>Plot beautiful figures by using our handcrafted plotting function.</li> <li>Apply any functions to batched arrays (e.g. <code>dq.wigner(states)</code> to compute the wigners of many states at once).</li> <li>Use QuTiP objects as arguments to any functions (e.g. if you have existing code to define your Hamiltonian in QuTiP, or if you want to use our nice plotting functions on a list of QuTiP states).</li> </ul>"},{"location":"documentation/getting_started/whatis.html#library-development","title":"Library development","text":"<ul> <li>Enjoy modern software development practices and tools.</li> <li>Build confidence from the analytical tests that verify state correctness and gradient accuracy for every solver, at each commit.</li> </ul>"},{"location":"documentation/getting_started/whatis.html#coming-soon","title":"Coming soon","text":"<ul> <li>Discover a custom sparse format, with substantial speedups for large systems.</li> <li>Simulate using propagators solvers based on Krylov subspace methods.</li> <li>Benchmark code to compare solvers and performance for different systems.</li> </ul>"},{"location":"python_api/index.html","title":"Python API","text":"<p>The Dynamiqs Python API features two main types of functions: solvers of differential equations describing quantum systems, and various utility functions to ease the creation and manipulation of quantum states and operators.</p>"},{"location":"python_api/index.html#quantum-solvers","title":"Quantum solvers","text":"<code>sesolve</code> <p>Solve the Schr\u00f6dinger equation. <code>mesolve</code> <p>Solve the Lindblad master equation. <code>smesolve</code> <p>Solve the diffusive stochastic master equation (SME). <code>sepropagator</code> <p>Compute the propagator of the Schr\u00f6dinger equation. <code>mepropagator</code> <p>Compute the propagator of the Lindblad master equation."},{"location":"python_api/index.html#core","title":"Core","text":""},{"location":"python_api/index.html#time-dependent-arrays","title":"Time-dependent arrays","text":"<code>TimeArray</code> <p>Base class for time-dependent arrays. <code>constant</code> <p>Instantiate a constant time-array. <code>pwc</code> <p>Instantiate a piecewise constant (PWC) time-array. <code>modulated</code> <p>Instantiate a modulated time-array. <code>timecallable</code> <p>Instantiate a callable time-array."},{"location":"python_api/index.html#solvers-dqsolver","title":"Solvers (dq.solver)","text":"<code>Tsit5</code> <p>Tsitouras method of order 5 (adaptive step size ODE solver). <code>Dopri5</code> <p>Dormand-Prince method of order 5 (adaptive step size ODE solver). <code>Dopri8</code> <p>Dormand-Prince method of order 8 (adaptive step size ODE solver). <code>Kvaerno3</code> <p>Kvaerno's method of order 3 (adaptive step size and implicit ODE solver). <code>Kvaerno5</code> <p>Kvaerno's method of order 5 (adaptive step size and implicit ODE solver). <code>Euler</code> <p>Euler method (fixed step size ODE solver). <code>Rouchon1</code> <p>First-order Rouchon method (fixed step size ODE solver). <code>Rouchon2</code> <p>Second-order Rouchon method (fixed step size ODE solver). <code>Expm</code> <p>Explicit matrix exponentiation to compute propagators."},{"location":"python_api/index.html#gradients-dqgradient","title":"Gradients (dq.gradient)","text":"<code>Autograd</code> <p>Standard automatic differentiation of JAX. <code>CheckpointAutograd</code> <p>Checkpointed automatic differentiation."},{"location":"python_api/index.html#options","title":"Options","text":"<code>Options</code> <p>Generic options for the quantum solvers."},{"location":"python_api/index.html#results","title":"Results","text":"<code>SESolveResult</code> <p>Result of the Schr\u00f6dinger equation integration. <code>MESolveResult</code> <p>Result of the Lindblad master equation integration. <code>SEPropagatorResult</code> <p>Result of the Schr\u00f6dinger equation integration to obtain the propagator. <code>MEPropagatorResult</code> <p>Result of the Lindblad master equation integration to obtain the propagator."},{"location":"python_api/index.html#utilities","title":"Utilities","text":""},{"location":"python_api/index.html#operators","title":"Operators","text":"<code>eye</code> <p>Returns the identity operator. <code>zero</code> <p>Returns the null operator. <code>destroy</code> <p>Returns a bosonic annihilation operator, or a tuple of annihilation operators for a multi-mode system. <code>create</code> <p>Returns a bosonic creation operator, or a tuple of creation operators for a multi-mode system. <code>number</code> <p>Returns the number operator of a bosonic mode, or a tuple of number operators for a multi-mode system. <code>parity</code> <p>Returns the parity operator of a bosonic mode. <code>displace</code> <p>Returns the displacement operator of complex amplitude \\(\\alpha\\). <code>squeeze</code> <p>Returns the squeezing operator of complex squeezing amplitude \\(z\\). <code>quadrature</code> <p>Returns the quadrature operator of phase angle \\(\\phi\\). <code>position</code> <p>Returns the position operator \\(x = (a^\\dag + a) / 2\\). <code>momentum</code> <p>Returns the momentum operator \\(p = i (a^\\dag - a) / 2\\). <code>sigmax</code> <p>Returns the Pauli \\(\\sigma_x\\) operator. <code>sigmay</code> <p>Returns the Pauli \\(\\sigma_y\\) operator. <code>sigmaz</code> <p>Returns the Pauli \\(\\sigma_z\\) operator. <code>sigmap</code> <p>Returns the Pauli raising operator \\(\\sigma_+\\). <code>sigmam</code> <p>Returns the Pauli lowering operator \\(\\sigma_-\\). <code>hadamard</code> <p>Returns the Hadamard transform on \\(n\\) qubits. <code>rx</code> <p>Returns the \\(R_x(\\theta)\\) rotation gate. <code>ry</code> <p>Returns the \\(R_y(\\theta)\\) rotation gate. <code>rz</code> <p>Returns the \\(R_z(\\theta)\\) rotation gate. <code>sgate</code> <p>Returns the \\(\\text{S}\\) gate. <code>tgate</code> <p>Returns the \\(\\text{T}\\) gate. <code>cnot</code> <p>Returns the \\(\\text{CNOT}\\) gate. <code>toffoli</code> <p>Returns the \\(\\text{Toffoli}\\) gate."},{"location":"python_api/index.html#states","title":"States","text":"<code>fock</code> <p>Returns the ket of a Fock state or a tensor product of Fock states. <code>fock_dm</code> <p>Returns the density matrix of a Fock state or a tensor product of Fock states. <code>basis</code> <p>Alias of <code>dq.fock()</code>. <code>basis_dm</code> <p>Alias of <code>dq.fock_dm()</code>. <code>coherent</code> <p>Returns the ket of a coherent state or a tensor product of coherent states. <code>coherent_dm</code> <p>Returns the density matrix of a coherent state or a tensor product of coherent states. <code>ground</code> <p>Returns the eigenvector with eigenvalue -1 of the Pauli \\(\\sigma_z\\) operator. <code>excited</code> <p>Returns the eigenvector with eigenvalue +1 of the Pauli \\(\\sigma_z\\) operator."},{"location":"python_api/index.html#quantum-utilities","title":"Quantum utilities","text":"<code>dag</code> <p>Returns the adjoint (complex conjugate transpose) of a matrix. <code>powm</code> <p>Returns the \\(n\\)-th matrix power of an array. <code>expm</code> <p>Returns the matrix exponential of an array. <code>cosm</code> <p>Returns the cosine of an array. <code>sinm</code> <p>Returns the sine of an array. <code>trace</code> <p>Returns the trace of an array along its last two dimensions. <code>tracemm</code> <p>Return the trace of a matrix multiplication using a fast implementation. <code>ptrace</code> <p>Returns the partial trace of a ket, bra or density matrix. <code>tensor</code> <p>Returns the tensor product of multiple kets, bras, density matrices or operators. <code>expect</code> <p>Returns the expectation value of an operator or list of operators on a ket, bra or density matrix. <code>norm</code> <p>Returns the norm of a ket, bra or density matrix. <code>unit</code> <p>Normalize a ket, bra or density matrix to unit norm. <code>dissipator</code> <p>Applies the Lindblad dissipation superoperator to a density matrix. <code>lindbladian</code> <p>Applies the Lindbladian superoperator to a density matrix. <code>isket</code> <p>Returns True if the array is in the format of a ket. <code>isbra</code> <p>Returns True if the array is in the format of a bra. <code>isdm</code> <p>Returns True if the array is in the format of a density matrix. <code>isop</code> <p>Returns True if the array is in the format of an operator. <code>isherm</code> <p>Returns True if the array is Hermitian. <code>toket</code> <p>Returns the ket representation of a pure quantum state. <code>tobra</code> <p>Returns the bra representation of a pure quantum state. <code>todm</code> <p>Returns the density matrix representation of a quantum state. <code>proj</code> <p>Returns the projection operator onto a pure quantum state. <code>braket</code> <p>Returns the inner product \\(\\braket{\\psi|\\varphi}\\) between two kets. <code>overlap</code> <p>Returns the overlap between two quantum states. <code>fidelity</code> <p>Returns the fidelity of two states, kets or density matrices. <code>entropy_vn</code> <p>Returns the Von Neumann entropy of a ket or density matrix. <code>bloch_coordinates</code> <p>Returns the spherical coordinates \\((r, \\theta, \\phi)\\) of a ket or density matrix on the Bloch sphere. <code>wigner</code> <p>Compute the Wigner distribution of a ket or density matrix."},{"location":"python_api/index.html#jax-related-utilities","title":"JAX-related utilities","text":"<code>to_qutip</code> <p>Convert an array-like object into a QuTiP quantum object (or a list of QuTiP quantum objects if it has more than two dimensions). <code>set_device</code> <p>Configure the default device. <code>set_precision</code> <p>Configure the default floating point precision. <code>set_matmul_precision</code> <p>Configure the default precision for matrix multiplications on GPUs and TPUs."},{"location":"python_api/index.html#vectorization","title":"Vectorization","text":"<code>operator_to_vector</code> <p>Returns the vectorized version of an operator. <code>vector_to_operator</code> <p>Returns the operator version of a vectorized operator. <code>spre</code> <p>Returns the superoperator formed from pre-multiplication by an operator. <code>spost</code> <p>Returns the superoperator formed from post-multiplication by an operator. <code>sprepost</code> <p>Returns the superoperator formed from pre- and post-multiplication by operators. <code>sdissipator</code> <p>Returns the Lindblad dissipation superoperator (in matrix form). <code>slindbladian</code> <p>Returns the Lindbladian superoperator (in matrix form)."},{"location":"python_api/index.html#quantum-optimal-control","title":"Quantum optimal control","text":"<code>snap_gate</code> <p>Returns a SNAP gate. <code>cd_gate</code> <p>Returns a conditional displacement gate."},{"location":"python_api/index.html#random-arrays-dqrandom","title":"Random arrays (dq.random)","text":"<code>real</code> <p>Returns an array of uniformly distributed random real numbers. <code>complex</code> <p>Returns an array of uniformly distributed random complex numbers. <code>herm</code> <p>Returns a random complex Hermitian matrix. <code>psd</code> <p>Returns a random complex positive semi-definite matrix. <code>dm</code> <p>Returns a random density matrix (hermitian, positive semi-definite, and unit trace). <code>ket</code> <p>Returns a random ket with unit norm."},{"location":"python_api/index.html#plotting-dqplot","title":"Plotting (dq.plot)","text":"<code>wigner</code> <p>Plot the Wigner function of a state. <code>wigner_mosaic</code> <p>Plot the Wigner function of multiple states in a mosaic arrangement. <code>wigner_gif</code> <p>Plot a GIF of the Wigner function of multiple states. <code>pwc_pulse</code> <p>Plot a piecewise constant pulse. <code>fock</code> <p>Plot the photon number population of a state. <code>fock_evolution</code> <p>Plot the photon number population of state as a function of time. <code>hinton</code> <p>Plot a Hinton diagram. <code>gifit</code> <p>Transform a plot function into a new function that returns an animated GIF. <code>grid</code> <p>Returns a figure and an iterator of subplots organised in a grid. <code>mplstyle</code> <p>Set custom Matplotlib style."},{"location":"python_api/gradient/Autograd.html","title":"Autograd","text":""},{"location":"python_api/gradient/Autograd.html#dynamiqs.gradient.Autograd","title":"dq.gradient.Autograd","text":"<pre><code>Autograd()\n</code></pre> <p>Standard automatic differentiation of JAX.</p> <p>With this option, the gradient is computed by automatically differentiating through the internals of the solver.</p> Note <p>For Diffrax-based solvers, this falls back to the <code>diffrax.DirectAdjoint</code> option.</p>"},{"location":"python_api/gradient/CheckpointAutograd.html","title":"CheckpointAutograd","text":""},{"location":"python_api/gradient/CheckpointAutograd.html#dynamiqs.gradient.CheckpointAutograd","title":"dq.gradient.CheckpointAutograd","text":"<pre><code>CheckpointAutograd(ncheckpoints: int | None = None)\n</code></pre> <p>Checkpointed automatic differentiation.</p> <p>With this option, the gradient is computed by automatically differentiating through the internals of the solver. The difference with the standard automatic differentiation (see <code>dq.gradient.Autograd</code>) is that a checkpointing scheme is used to reduce the memory usage of the backpropagation.</p> Note <p>For most problems this is the preferred technique for backpropagating through the quantum solvers.</p> Warning <p>This cannot be forward-mode autodifferentiated (e.g. using <code>jax.jvp</code> ). Try using <code>dq.gradient.Autograd</code> if that is something you need.</p> Note <p>For Diffrax-based solvers, this falls back to the <code>diffrax.RecursiveCheckpointAdjoint</code> option.</p> <p> Parameters </p> <ul> <li> ncheckpoints            \u2013 <p>Number of checkpoints to use. The amount of memory used by the differential equation solve will be roughly equal to the number of checkpoints multiplied by the size of the state. You can speed up backpropagation by allocating more checkpoints, so it makes sense to set as many checkpoints as you have memory for. This value is set to <code>None</code> by default, in which case it will be set to <code>log(max_steps)</code>, for which a theoretical result is available guaranteeing that backpropagation will take <code>O(n_steps log(n_steps))</code> time in the number of steps <code>n_steps &lt;= max_steps</code>.</p> </li> </ul>"},{"location":"python_api/integrators/mepropagator.html","title":"mepropagator","text":""},{"location":"python_api/integrators/mepropagator.html#dynamiqs.integrators.mepropagator","title":"dq.mepropagator","text":"<pre><code>mepropagator(\n    H: ArrayLike | TimeArray,\n    jump_ops: list[ArrayLike | TimeArray],\n    tsave: ArrayLike,\n    *,\n    solver: Solver = Expm(),\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; MEPropagatorResult\n</code></pre> <p>Compute the propagator of the Lindblad master equation.</p> <p>This function computes the propagator \\(\\mathcal{U}(t)\\) at time \\(t\\) of the Lindblad master equation (with \\(\\hbar=1\\)) $$     \\mathcal{U}(t) = \\mathscr{T}\\exp\\left(\\int_0^t\\mathcal{L}(t')\\dt'\\right), $$ where \\(\\mathscr{T}\\) is the time-ordering symbol and \\(\\mathcal{L}\\) is the system's Liouvillian. The formula simplifies to \\(\\mathcal{U}(t)=e^{t\\mathcal{L}}\\) if the Liouvillian does not depend on time.</p> Warning <p>This function only supports constant or piecewise constant Hamiltonians and jump operators. Support for arbitrary time dependence will be added soon.</p> Defining a time-dependent Hamiltonian or jump operator <p>If the Hamiltonian or the jump operators depend on time, they can be converted to time-arrays using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p> Running multiple simulations concurrently <p>The Hamiltonian <code>H</code> and the jump operators <code>jump_ops</code> can be batched to compute multiple propagators concurrently. All other arguments are common to every batch. See the Batching simulations tutorial for more details.</p> <p> Parameters </p> <ul> <li> H  (array-like or time-array of shape (...H, n, n))                         \u2013 <p>Hamiltonian.</p> </li> <li> jump_ops  (list of array-like or time-array, each of shape (...Lk, n, n))                         \u2013 <p>List of jump operators.</p> </li> <li> tsave  (array-like of shape (ntsave,))                         \u2013 <p>Times at which the propagators are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>, or from <code>t0</code> to <code>tsave[-1]</code> if <code>t0</code> is specified in <code>options</code>.</p> </li> <li> solver            \u2013 <p>Solver for the integration. Defaults to <code>dq.solver.Expm</code> (explicit matrix exponentiation), which is the only supported solver for now.</p> </li> <li> gradient            \u2013 <p>Algorithm used to compute the gradient. The default is solver-dependent, refer to the documentation of the chosen solver for more details.</p> </li> <li> options            \u2013 <p>Generic options, see <code>dq.Options</code>.</p> </li> </ul> <p> Returns </p> <p><code>dq.MEPropagatorResult</code> object holding the result of the propagator computation. Use the attribute <code>propagators</code> to access saved quantities, more details in <code>dq.MEPropagatorResult</code>.</p>"},{"location":"python_api/integrators/mesolve.html","title":"mesolve","text":""},{"location":"python_api/integrators/mesolve.html#dynamiqs.integrators.mesolve","title":"dq.mesolve","text":"<pre><code>mesolve(\n    H: ArrayLike | TimeArray,\n    jump_ops: list[ArrayLike | TimeArray],\n    rho0: ArrayLike,\n    tsave: ArrayLike,\n    *,\n    exp_ops: list[ArrayLike] | None = None,\n    solver: Solver = Tsit5(),\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; MESolveResult\n</code></pre> <p>Solve the Lindblad master equation.</p> <p>This function computes the evolution of the density matrix \\(\\rho(t)\\) at time \\(t\\), starting from an initial state \\(\\rho_0\\), according to the Lindblad master equation (with \\(\\hbar=1\\) and where time is implicit(1)) $$     \\frac{\\dd\\rho}{\\dt} = -i[H, \\rho]     + \\sum_{k=1}^N \\left(         L_k \\rho L_k^\\dag         - \\frac{1}{2} L_k^\\dag L_k \\rho         - \\frac{1}{2} \\rho L_k^\\dag L_k     \\right), $$ where \\(H\\) is the system's Hamiltonian and \\(\\{L_k\\}\\) is a collection of jump operators.</p> <ol> <li>With explicit time dependence:<ul> <li>\\(\\rho\\to\\rho(t)\\)</li> <li>\\(H\\to H(t)\\)</li> <li>\\(L_k\\to L_k(t)\\)</li> </ul> </li> </ol> Defining a time-dependent Hamiltonian or jump operator <p>If the Hamiltonian or the jump operators depend on time, they can be converted to time-arrays using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p> Running multiple simulations concurrently <p>The Hamiltonian <code>H</code>, the jump operators <code>jump_ops</code> and the initial density matrix <code>rho0</code> can be batched to solve multiple master equations concurrently. All other arguments are common to every batch. See the Batching simulations tutorial for more details.</p> <p> Parameters </p> <ul> <li> H  (array-like or time-array of shape (...H, n, n))                         \u2013 <p>Hamiltonian.</p> </li> <li> jump_ops  (list of array-like or time-array, each of shape (...Lk, n, n))                         \u2013 <p>List of jump operators.</p> </li> <li> rho0  (array-like of shape (...rho0, n, 1) or (...rho0, n, n))                         \u2013 <p>Initial state.</p> </li> <li> tsave  (array-like of shape (ntsave,))                         \u2013 <p>Times at which the states and expectation values are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>, or from <code>t0</code> to <code>tsave[-1]</code> if <code>t0</code> is specified in <code>options</code>.</p> </li> <li> exp_ops  (list of array-like, each of shape (n, n), optional)                         \u2013 <p>List of operators for which the expectation value is computed.</p> </li> <li> solver            \u2013 <p>Solver for the integration. Defaults to <code>dq.solver.Tsit5</code> (supported: <code>Tsit5</code>, <code>Dopri5</code>, <code>Dopri8</code>, <code>Kvaerno3</code>, <code>Kvaerno5</code>, <code>Euler</code>, <code>Rouchon1</code>, <code>Rouchon2</code>, <code>Expm</code>).</p> </li> <li> gradient            \u2013 <p>Algorithm used to compute the gradient. The default is solver-dependent, refer to the documentation of the chosen solver for more details.</p> </li> <li> options            \u2013 <p>Generic options, see <code>dq.Options</code>.</p> </li> </ul> <p> Returns </p> <p><code>dq.MESolveResult</code> object holding the result of the Lindblad master equation integration. Use the attributes <code>states</code> and <code>expects</code> to access saved quantities, more details in <code>dq.MESolveResult</code>.</p>"},{"location":"python_api/integrators/sepropagator.html","title":"sepropagator","text":""},{"location":"python_api/integrators/sepropagator.html#dynamiqs.integrators.sepropagator","title":"dq.sepropagator","text":"<pre><code>sepropagator(\n    H: ArrayLike | TimeArray,\n    tsave: ArrayLike,\n    *,\n    solver: Solver | None = None,\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; SEPropagatorResult\n</code></pre> <p>Compute the propagator of the Schr\u00f6dinger equation.</p> <p>This function computes the propagator \\(U(t)\\) at time \\(t\\) of the Schr\u00f6dinger equation (with \\(\\hbar=1\\)) $$     U(t) = \\mathscr{T}\\exp\\left(-i\\int_0^tH(t')\\dt'\\right), $$ where \\(\\mathscr{T}\\) is the time-ordering symbol and \\(H\\) is the system's Hamiltonian. The formula simplifies to \\(U(t)=e^{-iHt}\\) if the Hamiltonian does not depend on time.</p> <p>If the Hamiltonian is constant or piecewise constant, the propagator is computed by directly exponentiating the Hamiltonian. Otherwise, the propagator is computed by solving the Schr\u00f6dinger equation with an ODE solver.</p> Defining a time-dependent Hamiltonian <p>If the Hamiltonian depends on time, it can be converted to a time-array using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p> Running multiple simulations concurrently <p>The Hamiltonian <code>H</code> can be batched to compute multiple propagators concurrently. All other arguments are common to every batch. See the Batching simulations tutorial for more details.</p> <p> Parameters </p> <ul> <li> H  (array-like or time-array of shape (...H, n, n))                         \u2013 <p>Hamiltonian.</p> </li> <li> tsave  (array-like of shape (ntsave,))                         \u2013 <p>Times at which the propagators are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>, or from <code>t0</code> to <code>tsave[-1]</code> if <code>t0</code> is specified in <code>options</code>.</p> </li> <li> solver            \u2013 <p>Solver for the integration. Defaults to <code>None</code> which redirects to <code>dq.solver.Expm</code> (explicit matrix exponentiation) or <code>dq.solver.Tsit5</code> depending on the Hamiltonian type (supported: <code>Expm</code>, <code>Tsit5</code>, <code>Dopri5</code>, <code>Dopri8</code>, <code>Kvaerno3</code>, <code>Kvaerno5</code>, <code>Euler</code>).</p> </li> <li> gradient            \u2013 <p>Algorithm used to compute the gradient. The default is solver-dependent, refer to the documentation of the chosen solver for more details.</p> </li> <li> options            \u2013 <p>Generic options, see <code>dq.Options</code>.</p> </li> </ul> <p> Returns </p> <p><code>dq.SEPropagatorResult</code> object holding the result of the propagator computation. Use the attribute <code>propagators</code> to access saved quantities, more details in <code>dq.SEPropagatorResult</code>.</p>"},{"location":"python_api/integrators/sesolve.html","title":"sesolve","text":""},{"location":"python_api/integrators/sesolve.html#dynamiqs.integrators.sesolve","title":"dq.sesolve","text":"<pre><code>sesolve(\n    H: ArrayLike | TimeArray,\n    psi0: ArrayLike,\n    tsave: ArrayLike,\n    *,\n    exp_ops: list[ArrayLike] | None = None,\n    solver: Solver = Tsit5(),\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; SESolveResult\n</code></pre> <p>Solve the Schr\u00f6dinger equation.</p> <p>This function computes the evolution of the state vector \\(\\ket{\\psi(t)}\\) at time \\(t\\), starting from an initial state \\(\\ket{\\psi_0}\\), according to the Schr\u00f6dinger equation (with \\(\\hbar=1\\) and where time is implicit(1)) $$     \\frac{\\dd\\ket{\\psi}}{\\dt} = -i H \\ket{\\psi}, $$ where \\(H\\) is the system's Hamiltonian.</p> <ol> <li>With explicit time dependence:<ul> <li>\\(\\ket\\psi\\to\\ket{\\psi(t)}\\)</li> <li>\\(H\\to H(t)\\)</li> </ul> </li> </ol> Defining a time-dependent Hamiltonian <p>If the Hamiltonian depends on time, it can be converted to a time-array using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p> Running multiple simulations concurrently <p>Both the Hamiltonian <code>H</code> and the initial state <code>psi0</code> can be batched to solve multiple Schr\u00f6dinger equations concurrently. All other arguments are common to every batch. See the Batching simulations tutorial for more details.</p> <p> Parameters </p> <ul> <li> H  (array-like or time-array of shape (...H, n, n))                         \u2013 <p>Hamiltonian.</p> </li> <li> psi0  (array-like of shape (...psi0, n, 1))                         \u2013 <p>Initial state.</p> </li> <li> tsave  (array-like of shape (ntsave,))                         \u2013 <p>Times at which the states and expectation values are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>, or from <code>t0</code> to <code>tsave[-1]</code> if <code>t0</code> is specified in <code>options</code>.</p> </li> <li> exp_ops  (list of array-like, each of shape (n, n), optional)                         \u2013 <p>List of operators for which the expectation value is computed.</p> </li> <li> solver            \u2013 <p>Solver for the integration. Defaults to <code>dq.solver.Tsit5</code> (supported: <code>Tsit5</code>, <code>Dopri5</code>, <code>Dopri8</code>, <code>Kvaerno3</code>, <code>Kvaerno5</code>, <code>Euler</code>, <code>Expm</code>).</p> </li> <li> gradient            \u2013 <p>Algorithm used to compute the gradient. The default is solver-dependent, refer to the documentation of the chosen solver for more details.</p> </li> <li> options            \u2013 <p>Generic options, see <code>dq.Options</code>.</p> </li> </ul> <p> Returns </p> <p><code>dq.SESolveResult</code> object holding the result of the Schr\u00f6dinger equation integration. Use the attributes <code>states</code> and <code>expects</code> to access saved quantities, more details in <code>dq.SESolveResult</code>.</p>"},{"location":"python_api/integrators/smesolve.html","title":"smesolve","text":""},{"location":"python_api/integrators/smesolve.html#dynamiqs.integrators.smesolve","title":"dq.smesolve","text":"<pre><code>smesolve(\n    H: ArrayLike | TimeArray,\n    jump_ops: list[ArrayLike | TimeArray],\n    etas: ArrayLike,\n    rho0: ArrayLike,\n    tsave: ArrayLike,\n    *,\n    tmeas: ArrayLike | None = None,\n    ntrajs: int = 10,\n    exp_ops: list[ArrayLike] | None = None,\n    solver: Solver | None = None,\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; Result\n</code></pre> <p>Solve the diffusive stochastic master equation (SME).</p> Warning <p>This function has not been ported to JAX yet. The following documentation is a draft API, copied from the old PyTorch version of the library.</p> <p>This function computes the evolution of the density matrix \\(\\rho(t)\\) at time \\(t\\), starting from an initial state \\(\\rho_0\\), according to the diffusive SME in It\u00f4 form (with \\(\\hbar=1\\) and where time is implicit(1)) $$     \\begin{split}         \\dd\\rho =&amp;~ -i[H, \\rho]\\,\\dt + \\sum_{k=1}^N \\left(             L_k \\rho L_k^\\dag             - \\frac{1}{2} L_k^\\dag L_k \\rho             - \\frac{1}{2} \\rho L_k^\\dag L_k     \\right)\\dt \\\\         &amp;+ \\sum_{k=1}^N \\sqrt{\\eta_k} \\left(             L_k \\rho             + \\rho L_k^\\dag             - \\tr{(L_k+L_k^\\dag)\\rho}\\rho         \\right)\\dd W_k,     \\end{split} $$ where \\(H\\) is the system's Hamiltonian, \\(\\{L_k\\}\\) is a collection of jump operators, each continuously measured with efficiency \\(0\\leq\\eta_k\\leq1\\) (\\(\\eta_k=0\\) for purely dissipative loss channels) and \\(\\dd W_k\\) are independent Wiener processes.</p> <ol> <li>With explicit time dependence:<ul> <li>\\(\\rho\\to\\rho(t)\\)</li> <li>\\(H\\to H(t)\\)</li> <li>\\(L_k\\to L_k(t)\\)</li> <li>\\(\\dd W_k\\to \\dd W_k(t)\\)</li> </ul> </li> </ol> Diffusive vs. jump SME <p>In quantum optics the diffusive SME corresponds to homodyne or heterodyne detection schemes, as opposed to the jump SME which corresponds to photon counting schemes. No solver for the jump SME is provided yet, if this is needed don't hesitate to open an issue on GitHub.</p> <p>The measured signals \\(I_k=\\dd y_k/\\dt\\) verifies (again time is implicit): $$     \\dd y_k =\\sqrt{\\eta_k} \\tr{(L_k + L_k^\\dag) \\rho} \\dt + \\dd W_k. $$</p> Signal normalisation <p>Sometimes the signals are defined with a different but equivalent normalisation \\(\\dd y_k' = \\dd y_k/(2\\sqrt{\\eta_k})\\).</p> <p>The signals \\(I_k\\) are singular quantities, the solver returns the averaged signals \\(J_k\\) defined for a time interval \\([t_0, t_1)\\) by: $$     J_k([t_0, t_1)) = \\frac{1}{t_1-t_0}\\int_{t_0}^{t_1} I_k(t)\\, \\dt     = \\frac{1}{t_1-t_0}\\int_{t_0}^{t_1} \\dd y_k(t). $$ The time intervals for integration are defined by the argument <code>tmeas</code>, which defines <code>len(tmeas) - 1</code> intervals. By default, <code>tmeas = tsave</code>, so the signals are averaged between the times at which the states are saved.</p> Defining a time-dependent Hamiltonian or jump operator <p>If the Hamiltonian or the jump operators depend on time, they can be converted to time-arrays using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p> Running multiple simulations concurrently <p>The Hamiltonian <code>H</code>, the jump operators <code>jump_ops</code> and the initial density matrix <code>rho0</code> can be batched to solve multiple SMEs concurrently. All other arguments are common to every batch. See the Batching simulations tutorial for more details.</p> <p> Parameters </p> <ul> <li> H  (array-like or time-array of shape (bH?, n, n))                         \u2013 <p>Hamiltonian.</p> </li> <li> jump_ops  (list of array-like or time-array, of shape (nL, n, n))                         \u2013 <p>List of jump operators.</p> </li> <li> etas  (array-like of shape (nL,))                         \u2013 <p>Measurement efficiencies, must be of the same length as <code>jump_ops</code> with values between 0 and 1. For a purely dissipative loss channel, set the corresponding efficiency to 0. No measurement signal will be returned for such channels.</p> </li> <li> rho0  (array-like of shape (brho?, n, 1) or (brho?, n, n))                         \u2013 <p>Initial state.</p> </li> <li> tsave  (array-like of shape (ntsave,))                         \u2013 <p>Times at which the states and expectation values are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>, or from <code>t0</code> to <code>tsave[-1]</code> if <code>t0</code> is specified in <code>options</code>.</p> </li> <li> tmeas  (array-like of shape (ntmeas,), optional)                         \u2013 <p>Times between which measurement signals are averaged and saved. Defaults to <code>tsave</code>.</p> </li> <li> ntrajs            \u2013 <p>Number of stochastic trajectories to solve concurrently.</p> </li> <li> exp_ops  (list of array-like, of shape (nE, n, n), optional)                         \u2013 <p>List of operators for which the expectation value is computed.</p> </li> <li> solver            \u2013 <p>Solver for the integration.</p> </li> <li> gradient            \u2013 <p>Algorithm used to compute the gradient. The default is solver-dependent, refer to the documentation of the chosen solver for more details.</p> </li> <li> options            \u2013 <p>Generic options, see <code>dq.Options</code>.</p> </li> </ul>"},{"location":"python_api/options/Options.html","title":"Options","text":""},{"location":"python_api/options/Options.html#dynamiqs.options.Options","title":"dq.Options","text":"<pre><code>Options(\n    save_states: bool = True,\n    verbose: bool = True,\n    cartesian_batching: bool = True,\n    progress_meter: AbstractProgressMeter | None = TqdmProgressMeter(),\n    t0: ScalarLike | None = None,\n    save_extra: callable[[Array], PyTree] | None = None,\n)\n</code></pre> <p>Generic options for the quantum solvers.</p> <p> Parameters </p> <ul> <li> save_states            \u2013 <p>If <code>True</code>, the state is saved at every time in <code>tsave</code>, otherwise only the final state is returned.</p> </li> <li> verbose            \u2013 <p>If <code>True</code>, print information about the integration, otherwise nothing is printed.</p> </li> <li> cartesian_batching            \u2013 <p>If <code>True</code>, batched arguments are treated as separated batch dimensions, otherwise the batching is performed over a single shared batched dimension.</p> </li> <li> progress_meter            \u2013 <p>Progress meter indicating how far the solve has progressed. Defaults to a tqdm progress meter. Pass <code>None</code> for no output, see other options in dynamiqs/progress_meter.py. If gradients are computed, the progress meter only displays during the forward pass.</p> </li> <li> t0            \u2013 <p>Initial time. If <code>None</code>, defaults to the first time in <code>tsave</code>.</p> </li> <li> save_extra  (function, optional)                         \u2013 <p>A function with signature <code>f(Array) -&gt; PyTree</code> that takes a state or propagator as input and returns a PyTree. This can be used to save additional arbitrary data during the integration. The additional data is accessible in the <code>extra</code> attribute of the result object returned by the solvers.</p> </li> </ul>"},{"location":"python_api/plot/fock.html","title":"fock","text":""},{"location":"python_api/plot/fock.html#dynamiqs.plot.fock","title":"dq.plot.fock","text":"<pre><code>fock(\n    state: ArrayLike,\n    *,\n    ax: Axes | None = None,\n    allxticks: bool = False,\n    ymax: float | None = 1.0,\n    color: str = colors[\"blue\"],\n    alpha: float = 1.0,\n    label: str = \"\"\n)\n</code></pre> <p>Plot the photon number population of a state.</p> Warning <p>Documentation redaction in progress.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psi = dq.coherent(16, 2.0)\n&gt;&gt;&gt; dq.plot.fock(psi)\n&gt;&gt;&gt; renderfig('plot_fock')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; # the even cat state has only even photon number components\n&gt;&gt;&gt; psi = dq.unit(dq.coherent(32, 3.0) + dq.coherent(32, -3.0))\n&gt;&gt;&gt; dq.plot.fock(psi, allxticks=False, ymax=None)\n&gt;&gt;&gt; renderfig('plot_fock_even_cat')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; dq.plot.fock(dq.coherent(16, 1.0), alpha=0.5)\n&gt;&gt;&gt; dq.plot.fock(dq.coherent(16, 2.0), ax=plt.gca(), alpha=0.5, color='red')\n&gt;&gt;&gt; renderfig('plot_fock_coherent')\n</code></pre> <p></p>"},{"location":"python_api/plot/fock_evolution.html","title":"fock_evolution","text":""},{"location":"python_api/plot/fock_evolution.html#dynamiqs.plot.fock_evolution","title":"dq.plot.fock_evolution","text":"<pre><code>fock_evolution(\n    states: ArrayLike,\n    *,\n    ax: Axes | None = None,\n    times: ArrayLike | None = None,\n    cmap: str = \"Blues\",\n    logscale: bool = False,\n    logvmin: float = 0.0001,\n    colorbar: bool = True,\n    allyticks: bool = False\n)\n</code></pre> <p>Plot the photon number population of state as a function of time.</p> Warning <p>Documentation redaction in progress.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; a = dq.destroy(n)\n&gt;&gt;&gt; psi0 = dq.coherent(n, 0.0)\n&gt;&gt;&gt; H = 2.0 * (a + dq.dag(a))\n&gt;&gt;&gt; tsave = jnp.linspace(0, 1.0, 11)\n&gt;&gt;&gt; result = dq.sesolve(H, psi0, tsave)\n&gt;&gt;&gt; dq.plot.fock_evolution(result.states, times=tsave)\n&gt;&gt;&gt; renderfig('plot_fock_evolution')\n</code></pre> <p></p> <p>Use the log scale option to visualise low populations:</p> <pre><code>&gt;&gt;&gt; dq.plot.fock_evolution(result.states, times=tsave, logscale=True)\n&gt;&gt;&gt; renderfig('plot_fock_evolution_log')\n</code></pre> <p></p>"},{"location":"python_api/plot/gifit.html","title":"gifit","text":""},{"location":"python_api/plot/gifit.html#dynamiqs.plot.gifit","title":"dq.plot.gifit","text":"<pre><code>gifit(plot_function: callable[[T, ...], None]) -&gt; callable[[Sequence[T], ...], Image]\n</code></pre> <p>Transform a plot function into a new function that returns an animated GIF.</p> <p>This function takes a plot function that normally operates on a single input and returns a new function that creates a GIF from a sequence of inputs. The new function accepts two extra keyword arguments:</p> <ul> <li>gif_duration (float) -- GIF duration in seconds.</li> <li>fps (int) -- GIF frames per seconds.</li> </ul> <p>The new function returns an object of type <code>IPython.core.display.Image</code>, which automatically displays the GIF in Jupyter notebook environments (when the <code>Image</code> object is the last expression in a cell).</p> Save GIF to a file <p>The returned GIF can be saved to a file with:</p> <pre><code>with open('/path/to/file.gif').open('wb') as f:\n    f.write(gif.data)\n</code></pre> <p> Parameters </p> <ul> <li> plot_function            \u2013 <p>Plot function which must take as first positional argument the input that will be sequenced over by the new function. It must create a matplotlib <code>Figure</code> object and not close it.</p> </li> </ul> <p> Returns </p> <p>A new function with the same signature as <code>plot_function</code> which accepts a sequence of inputs and returns a GIF by applying the original <code>plot_function</code> to each element in the sequence.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; def plot_cos(phi):\n...     x = np.linspace(0, 1.0, 501)\n...     y = np.cos(2 * np.pi * x + phi)\n...     plt.figure(constrained_layout=True)\n...     plt.plot(x, y)\n&gt;&gt;&gt; phis = np.linspace(0, 2 * np.pi, 101)\n&gt;&gt;&gt; gif = dq.plot.gifit(plot_cos)(phis, fps=25)\n&gt;&gt;&gt; gif\n&lt;IPython.core.display.Image object&gt;\n&gt;&gt;&gt; rendergif(gif, 'cos')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; alphas = jnp.linspace(0.0, 3.0, 51)\n&gt;&gt;&gt; states = dq.coherent(24, alphas)\n&gt;&gt;&gt; gif = dq.plot.gifit(dq.plot.fock)(states, fps=25)\n&gt;&gt;&gt; rendergif(gif, 'coherent_evolution')\n</code></pre> <p></p>"},{"location":"python_api/plot/grid.html","title":"grid","text":""},{"location":"python_api/plot/grid.html#dynamiqs.plot.grid","title":"dq.plot.grid","text":"<pre><code>grid(\n    n: int,\n    nrows: int = 1,\n    *,\n    w: float = 3.0,\n    h: float | None = None,\n    sharexy: bool = False,\n    **kwargs\n) -&gt; tuple[Figure, Iterable[Axes]]\n</code></pre> <p>Returns a figure and an iterator of subplots organised in a grid.</p> Warning <p>Documentation redaction in progress.</p> Note <p>This method is a shortcut to Matplotlib <code>plt.subplots()</code>.</p> <p> Examples </p> <p>For example, to plot six different curves:</p> <pre><code>&gt;&gt;&gt; x = jnp.linspace(0, 1, 101)\n&gt;&gt;&gt; ys = [jnp.sin(f * 2 * jnp.pi * x) for f in range(6)]  # (6, 101)\n</code></pre> <p>Replace the usual Matplotlib code</p> <pre><code>&gt;&gt;&gt; fig, axs = plt.subplots(\n...     2, 3, figsize=(3 * 3.0, 2 * 3.0), sharex=True, sharey=True\n... )\n&gt;&gt;&gt; for i, y in enumerate(ys):\n...     axs[i // 3][i % 3].plot(x, y)\n[...]\n&gt;&gt;&gt; fig.tight_layout()\n</code></pre> <p>by</p> <pre><code>&gt;&gt;&gt; _, axs = dq.plot.grid(6, 2, sharexy=True)  # 6 subplots, 2 rows\n&gt;&gt;&gt; for y in ys:\n...     next(axs).plot(x, y)\n[...]\n&gt;&gt;&gt; renderfig('plot_grid')\n</code></pre> <p></p>"},{"location":"python_api/plot/hinton.html","title":"hinton","text":""},{"location":"python_api/plot/hinton.html#dynamiqs.plot.hinton","title":"dq.plot.hinton","text":"<pre><code>hinton(\n    x: ArrayLike,\n    *,\n    ax: Axes | None = None,\n    cmap: str | None = None,\n    vmin: float | None = None,\n    vmax: float | None = None,\n    colorbar: bool = True,\n    allticks: bool = False,\n    tickslabel: list[str] | None = None,\n    ecolor: str = \"white\",\n    ewidth: float = 0.5,\n    clear: bool = False\n)\n</code></pre> <p>Plot a Hinton diagram.</p> Warning <p>Documentation redaction in progress.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; rho = dq.coherent_dm(16, 2.0)\n&gt;&gt;&gt; dq.plot.hinton(jnp.abs(rho))\n&gt;&gt;&gt; renderfig('plot_hinton_coherent')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; a = dq.destroy(16)\n&gt;&gt;&gt; H = dq.dag(a) @ a + 2.0 * (a + dq.dag(a))\n&gt;&gt;&gt; dq.plot.hinton(jnp.abs(H))\n&gt;&gt;&gt; renderfig('plot_hinton_hamiltonian')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; cnot = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n&gt;&gt;&gt; dq.plot.hinton(cnot, tickslabel=['00', '01', '10', '11'])\n&gt;&gt;&gt; renderfig('plot_hinton_cnot')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; x = dq.random.complex(key, (16, 16))\n&gt;&gt;&gt; dq.plot.hinton(x)\n&gt;&gt;&gt; renderfig('plot_hinton_random_complex')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; _, axs = dq.plot.grid(2)\n&gt;&gt;&gt; psi = dq.unit(dq.fock(4, 0) - dq.fock(4, 2))\n&gt;&gt;&gt; dq.plot.hinton(dq.todm(psi), ax=next(axs))\n&gt;&gt;&gt; rho = dq.unit(dq.fock_dm(4, 0) + dq.fock_dm(4, 2))\n&gt;&gt;&gt; dq.plot.hinton(rho, ax=next(axs))\n&gt;&gt;&gt; renderfig('plot_hinton_fock02')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; _, axs = dq.plot.grid(2)\n&gt;&gt;&gt; x = np.random.uniform(-1.0, 1.0, (10, 10))\n&gt;&gt;&gt; dq.plot.hinton(x, ax=next(axs), vmin=-1.0, vmax=1.0)\n&gt;&gt;&gt; dq.plot.hinton(jnp.abs(x), ax=next(axs), cmap='Greys', vmax=1.0, ecolor='black')\n&gt;&gt;&gt; renderfig('plot_hinton_real')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; x = np.random.uniform(-1.0, 1.0, (100, 100))\n&gt;&gt;&gt; dq.plot.hinton(x, vmin=-1.0, vmax=1.0, ewidth=0, clear=True, w=20)\n&gt;&gt;&gt; renderfig('plot_hinton_large')\n</code></pre> <p></p>"},{"location":"python_api/plot/mplstyle.html","title":"mplstyle","text":""},{"location":"python_api/plot/mplstyle.html#dynamiqs.plot.mplstyle","title":"dq.plot.mplstyle","text":"<pre><code>mplstyle(*, usetex: bool = False, dpi: int = 72)\n</code></pre> <p>Set custom Matplotlib style.</p> Warning <p>Documentation redaction in progress.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; x = jnp.linspace(0, 2 * jnp.pi, 101)\n&gt;&gt;&gt; ys = [jnp.sin(x), jnp.sin(2 * x), jnp.sin(3 * x)]\n&gt;&gt;&gt; default_mpl_style()\n</code></pre> <p>Before (default Matplotlib style):</p> <pre><code>&gt;&gt;&gt; fig, ax = plt.subplots(1, 1)\n&gt;&gt;&gt; for y in ys:\n...     ax.plot(x, y)\n[...]\n&gt;&gt;&gt; ax.set(xlabel=r'$x$', ylabel=r'$\\sin(x)$')\n[...]\n&gt;&gt;&gt; renderfig('mplstyle_before')\n</code></pre> <p></p> <p>After (Dynamiqs Matplotlib style):</p> <pre><code>&gt;&gt;&gt; dq.plot.mplstyle(dpi=150)\n&gt;&gt;&gt; fig, ax = plt.subplots(1, 1)\n&gt;&gt;&gt; for y in ys:\n...     ax.plot(x, y)\n[...]\n&gt;&gt;&gt; ax.set(xlabel=r'$x$', ylabel=r'$\\sin(x)$')\n[...]\n&gt;&gt;&gt; renderfig('mplstyle_after')\n</code></pre> <p></p>"},{"location":"python_api/plot/pwc_pulse.html","title":"pwc_pulse","text":""},{"location":"python_api/plot/pwc_pulse.html#dynamiqs.plot.pwc_pulse","title":"dq.plot.pwc_pulse","text":"<pre><code>pwc_pulse(\n    times: ArrayLike,\n    values: ArrayLike,\n    *,\n    ax: Axes = None,\n    ycenter: bool = True,\n    real_color: str = colors[\"blue\"],\n    imag_color: str = colors[\"purple\"]\n)\n</code></pre> <p>Plot a piecewise constant pulse.</p> Warning <p>Documentation redaction in progress.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; n = 20\n&gt;&gt;&gt; times = jnp.linspace(0, 1.0, n + 1)\n&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; values = dq.random.complex(key, n)\n&gt;&gt;&gt; dq.plot.pwc_pulse(times, values)\n&gt;&gt;&gt; renderfig('plot_pwc_pulse')\n</code></pre> <p></p>"},{"location":"python_api/plot/wigner.html","title":"wigner","text":""},{"location":"python_api/plot/wigner.html#dynamiqs.plot.wigner","title":"dq.plot.wigner","text":"<pre><code>wigner(\n    state: ArrayLike,\n    *,\n    ax: Axes | None = None,\n    xmax: float = 5.0,\n    ymax: float | None = None,\n    vmax: float = 2 / jnp.pi,\n    npixels: int = 101,\n    cmap: str = \"dq\",\n    interpolation: str = \"bilinear\",\n    colorbar: bool = True,\n    cross: bool = False,\n    clear: bool = False\n)\n</code></pre> <p>Plot the Wigner function of a state.</p> Warning <p>Documentation redaction in progress.</p> Note <p>Choose a diverging colormap <code>cmap</code> for better results.</p> Warning <p>The axis scaling is chosen so that a coherent state \\(\\ket{\\alpha}\\) lies at the coordinates \\((x,y)=(\\mathrm{Re}(\\alpha),\\mathrm{Im}(\\alpha))\\), which is different from the default behaviour of <code>qutip.plot_wigner()</code>.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psi = dq.coherent(16, 2.0)\n&gt;&gt;&gt; dq.plot.wigner(psi)\n&gt;&gt;&gt; renderfig('plot_wigner_coh')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; psi = dq.unit(dq.coherent(16, 2) + dq.coherent(16, -2))\n&gt;&gt;&gt; dq.plot.wigner(psi, xmax=4.0, ymax=2.0, colorbar=False)\n&gt;&gt;&gt; renderfig('plot_wigner_cat')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; psi = dq.unit(dq.fock(2, 0) + dq.fock(2, 1))\n&gt;&gt;&gt; dq.plot.wigner(psi, xmax=2.0, cross=True)\n&gt;&gt;&gt; renderfig('plot_wigner_01')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; psi = dq.unit(sum(dq.coherent(32, 3 * a) for a in [1, 1j, -1, -1j]))\n&gt;&gt;&gt; dq.plot.wigner(psi, npixels=201, clear=True)\n&gt;&gt;&gt; renderfig('plot_wigner_4legged')\n</code></pre> <p></p>"},{"location":"python_api/plot/wigner_gif.html","title":"wigner_gif","text":""},{"location":"python_api/plot/wigner_gif.html#dynamiqs.plot.wigner_gif","title":"dq.plot.wigner_gif","text":"<pre><code>wigner_gif(\n    states: ArrayLike,\n    *,\n    gif_duration: float = 5.0,\n    fps: int = 10,\n    w: float = 5.0,\n    xmax: float = 5.0,\n    ymax: float | None = None,\n    vmax: float = 2 / jnp.pi,\n    npixels: int = 101,\n    cmap: str = \"dq\",\n    interpolation: str = \"bilinear\",\n    cross: bool = False,\n    clear: bool = False\n) -&gt; Image\n</code></pre> <p>Plot a GIF of the Wigner function of multiple states.</p> Warning <p>Documentation redaction in progress.</p> <p>See <code>dq.plot.wigner()</code> and <code>dq.plot.gifit()</code> for more details.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; a = dq.destroy(n)\n&gt;&gt;&gt; H = dq.zero(n)\n&gt;&gt;&gt; jump_ops = [a @ a - 4.0 * dq.eye(n)]  # cat state inflation\n&gt;&gt;&gt; psi0 = dq.coherent(n, 0)\n&gt;&gt;&gt; tsave = jnp.linspace(0, 1.0, 1001)\n&gt;&gt;&gt; result = dq.mesolve(H, jump_ops, psi0, tsave)\n&gt;&gt;&gt; gif = dq.plot.wigner_gif(result.states, fps=25, xmax=4.0, ymax=2.0)\n&gt;&gt;&gt; rendergif(gif, 'wigner-cat')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; a = dq.destroy(n)\n&gt;&gt;&gt; H = dq.dag(a) @ dq.dag(a) @ a @ a  # Kerr Hamiltonian\n&gt;&gt;&gt; psi0 = dq.coherent(n, 2)\n&gt;&gt;&gt; tsave = jnp.linspace(0, jnp.pi, 1001)\n&gt;&gt;&gt; result = dq.sesolve(H, psi0, tsave)\n&gt;&gt;&gt; gif = dq.plot.wigner_gif(\n...     result.states, gif_duration=10.0, fps=25, xmax=4.0, clear=True\n... )\n&gt;&gt;&gt; rendergif(gif, 'wigner-kerr')\n</code></pre> <p></p>"},{"location":"python_api/plot/wigner_mosaic.html","title":"wigner_mosaic","text":""},{"location":"python_api/plot/wigner_mosaic.html#dynamiqs.plot.wigner_mosaic","title":"dq.plot.wigner_mosaic","text":"<pre><code>wigner_mosaic(\n    states: ArrayLike,\n    *,\n    n: int = 8,\n    nrows: int = 1,\n    w: float = 3.0,\n    h: float | None = None,\n    xmax: float = 5.0,\n    ymax: float | None = None,\n    vmax: float = 2 / jnp.pi,\n    npixels: int = 101,\n    cmap: str = \"dq\",\n    interpolation: str = \"bilinear\",\n    cross: bool = False\n)\n</code></pre> <p>Plot the Wigner function of multiple states in a mosaic arrangement.</p> Warning <p>Documentation redaction in progress.</p> <p>See <code>dq.plot.wigner()</code> for more details.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psis = [dq.fock(3, i) for i in range(3)]\n&gt;&gt;&gt; dq.plot.wigner_mosaic(psis)\n&gt;&gt;&gt; renderfig('plot_wigner_mosaic_fock')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; a = dq.destroy(n)\n&gt;&gt;&gt; H = dq.zero(n)\n&gt;&gt;&gt; jump_ops = [a @ a - 4.0 * dq.eye(n)]  # cat state inflation\n&gt;&gt;&gt; psi0 = dq.coherent(n, 0)\n&gt;&gt;&gt; tsave = jnp.linspace(0, 1.0, 101)\n&gt;&gt;&gt; result = dq.mesolve(H, jump_ops, psi0, tsave)\n&gt;&gt;&gt; dq.plot.wigner_mosaic(result.states, n=6, xmax=4.0, ymax=2.0)\n&gt;&gt;&gt; renderfig('plot_wigner_mosaic_cat')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; a = dq.destroy(n)\n&gt;&gt;&gt; H = dq.dag(a) @ dq.dag(a) @ a @ a  # Kerr Hamiltonian\n&gt;&gt;&gt; psi0 = dq.coherent(n, 2)\n&gt;&gt;&gt; tsave = jnp.linspace(0, jnp.pi, 101)\n&gt;&gt;&gt; result = dq.sesolve(H, psi0, tsave)\n&gt;&gt;&gt; dq.plot.wigner_mosaic(result.states, n=25, nrows=5, xmax=4.0)\n&gt;&gt;&gt; renderfig('plot_wigner_mosaic_kerr')\n</code></pre> <p></p>"},{"location":"python_api/random/complex.html","title":"complex","text":""},{"location":"python_api/random/complex.html#dynamiqs.random.complex","title":"dq.random.complex","text":"<pre><code>complex(key: PRNGKeyArray, shape: int | tuple[int, ...], *, rmax: float = 1.0) -&gt; Array\n</code></pre> <p>Returns an array of uniformly distributed random complex numbers.</p> <p>Each element of the returned array is sampled uniformly in the disk of radius \\(\\text{rmax}\\).</p> Uniform sampling in the complex plane <p>Here are three common options to generate random complex numbers, <code>dq.random.complex()</code> returns the last one:</p> <pre><code>_, (ax0, ax1, ax2) = dq.plot.grid(3, sharexy=True)\nax0.set(xlim=(-1.1, 1.1), ylim=(-1.1, 1.1))\n\nn = 10_000\n\n# option 1: uniformly distributed real and imaginary part\nx = np.random.rand(n) * 2 - 1 + 1j * (np.random.rand(n) * 2 - 1)\nax0.scatter(x.real, x.imag, s=1.0)\n\n# option 2: uniformly distributed magnitude and phase\nx = np.random.rand(n) * jnp.exp(1j * 2 * jnp.pi * np.random.rand(n))\nax1.scatter(x.real, x.imag, s=1.0)\n\n# option 3: uniformly distributed in a disk (in Dynamiqs)\nkey = jax.random.PRNGKey(42)\nx = dq.random.complex(key, n)\nax2.scatter(x.real, x.imag, s=1.0)\nrenderfig('random_complex')\n</code></pre> <p></p> <p> Parameters </p> <ul> <li> key            \u2013 <p>A PRNG key used as the random key.</p> </li> <li> shape  (int or tuple of ints)                         \u2013 <p>Shape of the returned array.</p> </li> <li> rmax            \u2013 <p>Maximum magnitude.</p> </li> </ul> <p> Returns </p> <p>(array of shape (*shape)) Random complex number array.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.complex(key, (2, 3), rmax=5.0)\nArray([[ 1.341+4.17j ,  3.978-0.979j, -2.592-0.946j],\n       [-4.428+1.744j, -0.53 +1.668j,  2.582+0.65j ]], dtype=complex64)\n</code></pre>"},{"location":"python_api/random/dm.html","title":"dm","text":""},{"location":"python_api/random/dm.html#dynamiqs.random.dm","title":"dq.random.dm","text":"<pre><code>dm(key: PRNGKeyArray, shape: tuple[int, ...]) -&gt; Array\n</code></pre> <p>Returns a random density matrix (hermitian, positive semi-definite, and unit trace).</p> <p> Parameters </p> <ul> <li> key            \u2013 <p>A PRNG key used as the random key.</p> </li> <li> shape  (shape of the form (..., n, n))                         \u2013 <p>Shape of the returned array.</p> </li> </ul> <p> Returns </p> <p>(array of shape (*shape)) Random density matrix.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.dm(key, (2, 2))\nArray([[0.576+0.j   , 0.293+0.166j],\n       [0.293-0.166j, 0.424+0.j   ]], dtype=complex64)\n</code></pre>"},{"location":"python_api/random/herm.html","title":"herm","text":""},{"location":"python_api/random/herm.html#dynamiqs.random.herm","title":"dq.random.herm","text":"<pre><code>herm(key: PRNGKeyArray, shape: tuple[int, ...]) -&gt; Array\n</code></pre> <p>Returns a random complex Hermitian matrix.</p> <p> Parameters </p> <ul> <li> key            \u2013 <p>A PRNG key used as the random key.</p> </li> <li> shape  (shape of the form (..., n, n))                         \u2013 <p>Shape of the returned array.</p> </li> </ul> <p> Returns </p> <p>(array of shape (*shape)) Random complex Hermitian matrix.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.herm(key, (2, 2))\nArray([[-0.291+0.j   ,  0.473-0.446j],\n       [ 0.473+0.446j,  0.13 +0.j   ]], dtype=complex64)\n</code></pre>"},{"location":"python_api/random/ket.html","title":"ket","text":""},{"location":"python_api/random/ket.html#dynamiqs.random.ket","title":"dq.random.ket","text":"<pre><code>ket(key: PRNGKeyArray, shape: tuple[int, ...]) -&gt; Array\n</code></pre> <p>Returns a random ket with unit norm.</p> <p> Parameters </p> <ul> <li> key            \u2013 <p>A PRNG key used as the random key.</p> </li> <li> shape  (shape of the form (..., n, 1))                         \u2013 <p>Shape of the returned array.</p> </li> </ul> <p> Returns </p> <p>(array of shape (*shape)) Random ket.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.ket(key, (2, 1))\nArray([[-0.004+0.083j],\n       [-0.26 +0.962j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/random/psd.html","title":"psd","text":""},{"location":"python_api/random/psd.html#dynamiqs.random.psd","title":"dq.random.psd","text":"<pre><code>psd(key: PRNGKeyArray, shape: tuple[int, ...]) -&gt; Array\n</code></pre> <p>Returns a random complex positive semi-definite matrix.</p> <p> Parameters </p> <ul> <li> key            \u2013 <p>A PRNG key used as the random key.</p> </li> <li> shape  (shape of the form (..., n, n))                         \u2013 <p>Shape of the returned array.</p> </li> </ul> <p> Returns </p> <p>(array of shape (*shape)) Random complex positive semi-definite matrix.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.psd(key, (2, 2))\nArray([[1.145+0.j  , 0.582+0.33j],\n       [0.582-0.33j, 0.844+0.j  ]], dtype=complex64)\n</code></pre>"},{"location":"python_api/random/real.html","title":"real","text":""},{"location":"python_api/random/real.html#dynamiqs.random.real","title":"dq.random.real","text":"<pre><code>real(\n    key: PRNGKeyArray,\n    shape: int | tuple[int, ...],\n    *,\n    min: float = 0.0,\n    max: float = 1.0\n) -&gt; Array\n</code></pre> <p>Returns an array of uniformly distributed random real numbers.</p> <p>Each element of the returned array is sampled uniformly in \\([\\text{min}, \\text{max})\\).</p> <p> Parameters </p> <ul> <li> key            \u2013 <p>A PRNG key used as the random key.</p> </li> <li> shape  (int or tuple of ints)                         \u2013 <p>Shape of the returned array.</p> </li> <li> min            \u2013 <p>Minimum (inclusive) value.</p> </li> <li> max            \u2013 <p>Maximum (exclusive) value.</p> </li> </ul> <p> Returns </p> <p>(array of shape (*shape)) Random real number array.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.real(key, (2, 5), max=5.0)\nArray([[3.22 , 1.613, 0.967, 4.432, 4.21 ],\n       [0.96 , 1.726, 1.262, 3.16 , 3.274]], dtype=float32)\n</code></pre>"},{"location":"python_api/result/MEPropagatorResult.html","title":"MEPropagatorResult","text":""},{"location":"python_api/result/MEPropagatorResult.html#dynamiqs.result.MEPropagatorResult","title":"dq.MEPropagatorResult","text":"<p>Result of the Lindblad master equation integration to obtain the propagator.</p> <p> Attributes </p> <ul> <li> propagators  (array of shape (..., nsave, n^2, n^2))                         \u2013 <p>Saved propagators with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if <code>options.save_states</code> is set to <code>False</code>.</p> </li> <li> final_propagator  (array of shape (..., n^2, n^2))                         \u2013 <p>Saved final propagator.</p> </li> <li> extra  (PyTree or None)                         \u2013 <p>Extra data saved with <code>save_extra()</code> if specified in <code>options</code> (see <code>dq.Options</code>).</p> </li> <li> infos  (PyTree or None)                         \u2013 <p>Solver-dependent information on the resolution.</p> </li> <li> tsave  (array of shape (ntsave,))                         \u2013 <p>Times for which results were saved.</p> </li> <li> solver  (Solver)                         \u2013 <p>Solver used.</p> </li> <li> gradient  (Gradient)                         \u2013 <p>Gradient used.</p> </li> <li> options  (Options)                         \u2013 <p>Options used.</p> </li> </ul> Result of running multiple simulations concurrently <p>The resulting propagators are batched according to the leading dimensions of the Hamiltonian <code>H</code> and jump operators <code>jump_ops</code>. The behaviour depends on the value of the <code>cartesian_batching</code> option</p> If <code>cartesian_batching = True</code> (default value)If <code>cartesian_batching = False</code> <p>The results leading dimensions are <pre><code>... = ...H, ...L0, ...L1, (...)\n</code></pre> For example if:</p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(4, 5, n, n), (6, n, n)],</li> </ul> <p>then <code>propagators</code> has shape (2, 3, 4, 5, 6, ntsave, n, n).</p> <p>The results leading dimensions are <pre><code>... = ...H = ...L0 = ...L1 = (...)  # (once broadcasted)\n</code></pre> For example if:</p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(3, n, n), (2, 1, n, n)],</li> </ul> <p>then <code>propagators</code> has shape (2, 3, ntsave, n, n).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/result/MESolveResult.html","title":"MESolveResult","text":""},{"location":"python_api/result/MESolveResult.html#dynamiqs.result.MESolveResult","title":"dq.MESolveResult","text":"<p>Result of the Lindblad master equation integration.</p> <p> Attributes </p> <ul> <li> states  (array of shape (..., nsave, n, n))                         \u2013 <p>Saved states with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if <code>options.save_states</code> is set to <code>False</code>.</p> </li> <li> final_state  (array of shape (..., n, n))                         \u2013 <p>Saved final state.</p> </li> <li> expects  (array of shape (..., len(exp_ops), ntsave) or None)                         \u2013 <p>Saved expectation values, if specified by <code>exp_ops</code>.</p> </li> <li> extra  (PyTree or None)                         \u2013 <p>Extra data saved with <code>save_extra()</code> if specified in <code>options</code> (see <code>dq.Options</code>).</p> </li> <li> infos  (PyTree or None)                         \u2013 <p>Solver-dependent information on the resolution.</p> </li> <li> tsave  (array of shape (ntsave,))                         \u2013 <p>Times for which results were saved.</p> </li> <li> solver  (Solver)                         \u2013 <p>Solver used.</p> </li> <li> gradient  (Gradient)                         \u2013 <p>Gradient used.</p> </li> <li> options  (Options)                         \u2013 <p>Options used.</p> </li> </ul> Result of running multiple simulations concurrently <p>The resulting states and expectation values are batched according to the leading dimensions of the Hamiltonian <code>H</code>, jump operators <code>jump_ops</code> and initial state <code>rho0</code>. The behaviour depends on the value of the <code>cartesian_batching</code> option</p> If <code>cartesian_batching = True</code> (default value)If <code>cartesian_batching = False</code> <p>The results leading dimensions are <pre><code>... = ...H, ...L0, ...L1, (...), ...rho0\n</code></pre> For example if:</p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(4, 5, n, n), (6, n, n)],</li> <li><code>rho0</code> has shape (7, n, n),</li> </ul> <p>then <code>states</code> has shape (2, 3, 4, 5, 6, 7, ntsave, n, n).</p> <p>The results leading dimensions are <pre><code>... = ...H = ...L0 = ...L1 = (...) = ...rho0  # (once broadcasted)\n</code></pre> For example if:</p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(3, n, n), (2, 1, n, n)],</li> <li><code>rho0</code> has shape (3, n, n),</li> </ul> <p>then <code>states</code> has shape (2, 3, ntsave, n, n).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/result/SEPropagatorResult.html","title":"SEPropagatorResult","text":""},{"location":"python_api/result/SEPropagatorResult.html#dynamiqs.result.SEPropagatorResult","title":"dq.SEPropagatorResult","text":"<p>Result of the Schr\u00f6dinger equation integration to obtain the propagator.</p> <p> Attributes </p> <ul> <li> propagators  (array of shape (..., nsave, n, n))                         \u2013 <p>Saved propagators with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if <code>options.save_states</code> is set to <code>False</code>.</p> </li> <li> final_propagator  (array of shape (..., n, n))                         \u2013 <p>Saved final propagator.</p> </li> <li> extra  (PyTree or None)                         \u2013 <p>Extra data saved with <code>save_extra()</code> if specified in <code>options</code> (see <code>dq.Options</code>).</p> </li> <li> infos  (PyTree or None)                         \u2013 <p>Solver-dependent information on the resolution.</p> </li> <li> tsave  (array of shape (ntsave,))                         \u2013 <p>Times for which results were saved.</p> </li> <li> solver  (Solver)                         \u2013 <p>Solver used.</p> </li> <li> gradient  (Gradient)                         \u2013 <p>Gradient used.</p> </li> <li> options  (Options)                         \u2013 <p>Options used.</p> </li> </ul> Result of running multiple simulations concurrently <p>The resulting propagators are batched according to the leading dimensions of the Hamiltonian <code>H</code>. For example if <code>H</code> has shape (2, 3, n, n), then <code>propagators</code> has shape (2, 3, ntsave, n, n).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/result/SESolveResult.html","title":"SESolveResult","text":""},{"location":"python_api/result/SESolveResult.html#dynamiqs.result.SESolveResult","title":"dq.SESolveResult","text":"<p>Result of the Schr\u00f6dinger equation integration.</p> <p> Attributes </p> <ul> <li> states  (array of shape (..., nsave, n, 1))                         \u2013 <p>Saved states with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if <code>options.save_states</code> is set to <code>False</code>.</p> </li> <li> final_state  (array of shape (..., n, 1))                         \u2013 <p>Saved final state.</p> </li> <li> expects  (array of shape (..., len(exp_ops), ntsave) or None)                         \u2013 <p>Saved expectation values, if specified by <code>exp_ops</code>.</p> </li> <li> extra  (PyTree or None)                         \u2013 <p>Extra data saved with <code>save_extra()</code> if specified in <code>options</code> (see <code>dq.Options</code>).</p> </li> <li> infos  (PyTree or None)                         \u2013 <p>Solver-dependent information on the resolution.</p> </li> <li> tsave  (array of shape (ntsave,))                         \u2013 <p>Times for which results were saved.</p> </li> <li> solver  (Solver)                         \u2013 <p>Solver used.</p> </li> <li> gradient  (Gradient)                         \u2013 <p>Gradient used.</p> </li> <li> options  (Options)                         \u2013 <p>Options used.</p> </li> </ul> Result of running multiple simulations concurrently <p>The resulting states and expectation values are batched according to the leading dimensions of the Hamiltonian <code>H</code> and initial state <code>psi0</code>. The behaviour depends on the value of the <code>cartesian_batching</code> option</p> If <code>cartesian_batching = True</code> (default value)If <code>cartesian_batching = False</code> <p>The results leading dimensions are <pre><code>... = ...H, ...psi0\n</code></pre> For example if:</p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>psi0</code> has shape (4, n, 1),</li> </ul> <p>then <code>states</code> has shape (2, 3, 4, ntsave, n, 1).</p> <p>The results leading dimensions are <pre><code>... = ...H = ...psi0  # (once broadcasted)\n</code></pre> For example if:</p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>psi0</code> has shape (3, n, 1),</li> </ul> <p>then <code>states</code> has shape (2, 3, ntsave, n, 1).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/solver/Dopri5.html","title":"Dopri5","text":""},{"location":"python_api/solver/Dopri5.html#dynamiqs.solver.Dopri5","title":"dq.solver.Dopri5","text":"<pre><code>Dopri5(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n)\n</code></pre> <p>Dormand-Prince method of order 5 (adaptive step size ODE solver).</p> <p>This solver is implemented by the Diffrax library, see <code>diffrax.Dopri5</code>.</p> <p> Parameters </p> <ul> <li> rtol            \u2013 <p>Relative tolerance.</p> </li> <li> atol            \u2013 <p>Absolute tolerance.</p> </li> <li> safety_factor            \u2013 <p>Safety factor for adaptive step sizing.</p> </li> <li> min_factor            \u2013 <p>Minimum factor for adaptive step sizing.</p> </li> <li> max_factor            \u2013 <p>Maximum factor for adaptive step sizing.</p> </li> <li> max_steps            \u2013 <p>Maximum number of steps.</p> </li> </ul> Supported gradients <p>This solver supports differentiation with <code>dq.gradient.Autograd</code> and <code>dq.gradient.CheckpointAutograd</code> (default).</p>"},{"location":"python_api/solver/Dopri8.html","title":"Dopri8","text":""},{"location":"python_api/solver/Dopri8.html#dynamiqs.solver.Dopri8","title":"dq.solver.Dopri8","text":"<pre><code>Dopri8(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n)\n</code></pre> <p>Dormand-Prince method of order 8 (adaptive step size ODE solver).</p> <p>This solver is implemented by the Diffrax library, see <code>diffrax.Dopri8</code>.</p> <p> Parameters </p> <ul> <li> rtol            \u2013 <p>Relative tolerance.</p> </li> <li> atol            \u2013 <p>Absolute tolerance.</p> </li> <li> safety_factor            \u2013 <p>Safety factor for adaptive step sizing.</p> </li> <li> min_factor            \u2013 <p>Minimum factor for adaptive step sizing.</p> </li> <li> max_factor            \u2013 <p>Maximum factor for adaptive step sizing.</p> </li> <li> max_steps            \u2013 <p>Maximum number of steps.</p> </li> </ul> Supported gradients <p>This solver supports differentiation with <code>dq.gradient.Autograd</code> and <code>dq.gradient.CheckpointAutograd</code> (default).</p>"},{"location":"python_api/solver/Euler.html","title":"Euler","text":""},{"location":"python_api/solver/Euler.html#dynamiqs.solver.Euler","title":"dq.solver.Euler","text":"<pre><code>Euler(dt: float)\n</code></pre> <p>Euler method (fixed step size ODE solver).</p> <p>This solver is implemented by the Diffrax library, see <code>diffrax.Euler</code>.</p> Warning <p>This solver is not recommended for general use.</p> <p> Parameters </p> <ul> <li> dt            \u2013 <p>Fixed time step.</p> </li> </ul> Supported gradients <p>This solver supports differentiation with <code>dq.gradient.Autograd</code> and <code>dq.gradient.CheckpointAutograd</code> (default).</p>"},{"location":"python_api/solver/Expm.html","title":"Expm","text":""},{"location":"python_api/solver/Expm.html#dynamiqs.solver.Expm","title":"dq.solver.Expm","text":"<pre><code>Expm()\n</code></pre> <p>Explicit matrix exponentiation to compute propagators.</p> <p>Explicitly batch-compute the propagators for all time intervals in <code>tsave</code>. These propagators are then iteratively applied:</p> <ul> <li>starting from the initial state for <code>dq.sesolve()</code> and   <code>dq.mesolve()</code>, to compute states for all times in <code>tsave</code>,</li> <li>starting from the identity matrix for <code>dq.sepropagator()</code>   and <code>dq.mepropagator()</code>, to compute propagators for all   times in <code>tsave</code>.</li> </ul> <p>For the Schr\u00f6dinger equation with constant Hamiltonian \\(H\\), the propagator from time \\(t_0\\) to time \\(t_1\\) is an \\(n\\times n\\) matrix given by $$     U(t_0, t_1) = \\exp(-i (t_1 - t_0) H). $$</p> <p>For the Lindblad master equation with constant Liouvillian \\(\\mathcal{L}\\), the problem is vectorized and the propagator from time \\(t_0\\) to time \\(t_1\\) is an \\(n^2\\times n^2\\) matrix given by $$     \\mathcal{U}(t_0, t_1) = \\exp((t_1 - t_0)\\mathcal{L}). $$</p> Warning <p>This solver is not recommended for open systems of large dimension, due to the \\(\\mathcal{O}(n^6)\\) scaling of computing the Liouvillian exponential.</p> Warning <p>This solver only supports constant or piecewise constant Hamiltonian and jump operators.</p> Supported gradients <p>This solver supports differentiation with <code>dq.gradient.Autograd</code> (default).</p>"},{"location":"python_api/solver/Kvaerno3.html","title":"Kvaerno3","text":""},{"location":"python_api/solver/Kvaerno3.html#dynamiqs.solver.Kvaerno3","title":"dq.solver.Kvaerno3","text":"<pre><code>Kvaerno3(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n)\n</code></pre> <p>Kvaerno's method of order 3 (adaptive step size and implicit ODE solver).</p> <p>This method is suitable for stiff problems, typically those with Hamiltonians or Liouvillians that have eigenvalues spanning different orders of magnitudes. This is for instance the case with problems involving high-order polynomials of the bosonic annihilation and creation operators, in large dimensions.</p> <p>This solver is implemented by the Diffrax library, see <code>diffrax.Kvaerno3</code>.</p> Warning <p>If you find that your simulation is slow or that the progress bar gets stuck, consider switching to double-precision with <code>dq.set_precision('double')</code>. See more details in The sharp bits \ud83d\udd2a tutorial.</p> <p> Parameters </p> <ul> <li> rtol            \u2013 <p>Relative tolerance.</p> </li> <li> atol            \u2013 <p>Absolute tolerance.</p> </li> <li> safety_factor            \u2013 <p>Safety factor for adaptive step sizing.</p> </li> <li> min_factor            \u2013 <p>Minimum factor for adaptive step sizing.</p> </li> <li> max_factor            \u2013 <p>Maximum factor for adaptive step sizing.</p> </li> <li> max_steps            \u2013 <p>Maximum number of steps.</p> </li> </ul> Supported gradients <p>This solver supports differentiation with <code>dq.gradient.Autograd</code> and <code>dq.gradient.CheckpointAutograd</code> (default).</p>"},{"location":"python_api/solver/Kvaerno5.html","title":"Kvaerno5","text":""},{"location":"python_api/solver/Kvaerno5.html#dynamiqs.solver.Kvaerno5","title":"dq.solver.Kvaerno5","text":"<pre><code>Kvaerno5(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n)\n</code></pre> <p>Kvaerno's method of order 5 (adaptive step size and implicit ODE solver).</p> <p>This method is suitable for stiff problems, typically those with Hamiltonians or Liouvillians that have eigenvalues spanning different orders of magnitudes. This is for instance the case with problems involving high-order polynomials of the bosonic annihilation and creation operators, in large dimensions.</p> <p>This solver is implemented by the Diffrax library, see <code>diffrax.Kvaerno5</code>.</p> Warning <p>If you find that your simulation is slow or that the progress bar gets stuck, consider switching to double-precision with <code>dq.set_precision('double')</code>. See more details in The sharp bits \ud83d\udd2a tutorial.</p> <p> Parameters </p> <ul> <li> rtol            \u2013 <p>Relative tolerance.</p> </li> <li> atol            \u2013 <p>Absolute tolerance.</p> </li> <li> safety_factor            \u2013 <p>Safety factor for adaptive step sizing.</p> </li> <li> min_factor            \u2013 <p>Minimum factor for adaptive step sizing.</p> </li> <li> max_factor            \u2013 <p>Maximum factor for adaptive step sizing.</p> </li> <li> max_steps            \u2013 <p>Maximum number of steps.</p> </li> </ul> Supported gradients <p>This solver supports differentiation with <code>dq.gradient.Autograd</code> and <code>dq.gradient.CheckpointAutograd</code> (default).</p>"},{"location":"python_api/solver/Rouchon1.html","title":"Rouchon1","text":""},{"location":"python_api/solver/Rouchon1.html#dynamiqs.solver.Rouchon1","title":"dq.solver.Rouchon1","text":"<pre><code>Rouchon1(dt: float)\n</code></pre> <p>First-order Rouchon method (fixed step size ODE solver).</p> <p> Parameters </p> <ul> <li> dt            \u2013 <p>Fixed time step.</p> </li> </ul> Supported gradients <p>This solver supports differentiation with <code>dq.gradient.Autograd</code> and <code>dq.gradient.CheckpointAutograd</code> (default).</p>"},{"location":"python_api/solver/Rouchon2.html","title":"Rouchon2","text":""},{"location":"python_api/solver/Rouchon2.html#dynamiqs.solver.Rouchon2","title":"dq.solver.Rouchon2","text":"<pre><code>Rouchon2(dt: float)\n</code></pre> <p>Second-order Rouchon method (fixed step size ODE solver).</p> Warning <p>This solver has not been ported to JAX yet.</p> <p> Parameters </p> <ul> <li> dt            \u2013 <p>Fixed time step.</p> </li> </ul> Supported gradients <p>This solver supports differentiation with <code>dq.gradient.Autograd</code> and <code>dq.gradient.CheckpointAutograd</code> (default).</p>"},{"location":"python_api/solver/Tsit5.html","title":"Tsit5","text":""},{"location":"python_api/solver/Tsit5.html#dynamiqs.solver.Tsit5","title":"dq.solver.Tsit5","text":"<pre><code>Tsit5(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n)\n</code></pre> <p>Tsitouras method of order 5 (adaptive step size ODE solver).</p> <p>This solver is implemented by the Diffrax library, see <code>diffrax.Tsit5</code>.</p> <p> Parameters </p> <ul> <li> rtol            \u2013 <p>Relative tolerance.</p> </li> <li> atol            \u2013 <p>Absolute tolerance.</p> </li> <li> safety_factor            \u2013 <p>Safety factor for adaptive step sizing.</p> </li> <li> min_factor            \u2013 <p>Minimum factor for adaptive step sizing.</p> </li> <li> max_factor            \u2013 <p>Maximum factor for adaptive step sizing.</p> </li> <li> max_steps            \u2013 <p>Maximum number of steps.</p> </li> </ul> Supported gradients <p>This solver supports differentiation with <code>dq.gradient.Autograd</code> and <code>dq.gradient.CheckpointAutograd</code> (default).</p>"},{"location":"python_api/time_array/TimeArray.html","title":"TimeArray","text":""},{"location":"python_api/time_array/TimeArray.html#dynamiqs.time_array.TimeArray","title":"dq.TimeArray","text":"<p>Base class for time-dependent arrays.</p> <p>A time-array is a callable object that returns a JAX array for any time \\(t\\). It is used to define time-dependent operators for Dynamiqs solvers.</p> <p> Attributes </p> <ul> <li> dtype  (numpy.dtype)                         \u2013 <p>Data type.</p> </li> <li> shape  (tuple of int)                         \u2013 <p>Shape.</p> </li> <li> mT  (TimeArray)                         \u2013 <p>Returns the time-array transposed over its last two dimensions.</p> </li> <li> ndim  (int)                         \u2013 <p>Number of dimensions.</p> </li> <li> discontinuity_ts  (Array | None)                         \u2013 <p>Times at which there is a discontinuous jump in the time-array values (the array is always sorted, but does not necessarily contain unique values).</p> </li> </ul> Arithmetic operation support <p>Time-arrays support elementary operations:</p> <ul> <li>negation (<code>__neg__</code>),</li> <li>left-and-right element-wise addition/subtraction with other arrays or     time-arrays (<code>__add__</code>, <code>__radd__</code>, <code>__sub__</code>, <code>__rsub__</code>),</li> <li>left-and-right element-wise multiplication with other arrays (<code>__mul__</code>,     <code>__rmul__</code>).</li> </ul>"},{"location":"python_api/time_array/TimeArray.html#dynamiqs.time_array.TimeArray.reshape","title":"TimeArray.reshape  <code>abstractmethod</code>","text":"<pre><code>reshape(*shape: int) -&gt; TimeArray\n</code></pre> <p>Returns a reshaped copy of a time-array.</p> <p> Parameters </p> <ul> <li> *shape            \u2013 <p>New shape, which must match the original size.</p> </li> </ul> <p> Returns </p> <p>New time-array object with the given shape.</p>"},{"location":"python_api/time_array/TimeArray.html#dynamiqs.time_array.TimeArray.broadcast_to","title":"TimeArray.broadcast_to  <code>abstractmethod</code>","text":"<pre><code>broadcast_to(*shape: int) -&gt; TimeArray\n</code></pre> <p>Broadcasts a time-array to a new shape.</p> <p> Parameters </p> <ul> <li> *shape            \u2013 <p>New shape, which must be compatible with the original shape.</p> </li> </ul> <p> Returns </p> <p>New time-array object with the given shape.</p>"},{"location":"python_api/time_array/TimeArray.html#dynamiqs.time_array.TimeArray.conj","title":"TimeArray.conj  <code>abstractmethod</code>","text":"<pre><code>conj() -&gt; TimeArray\n</code></pre> <p>Returns the element-wise complex conjugate of the time-array.</p> <p> Returns </p> <p>New time-array object with element-wise complex conjuguated values.</p>"},{"location":"python_api/time_array/TimeArray.html#dynamiqs.time_array.TimeArray.squeeze","title":"TimeArray.squeeze","text":"<pre><code>squeeze(axis: int | None = None) -&gt; TimeArray\n</code></pre> <p>Squeeze a time-array.</p> <p> Parameters </p> <ul> <li> axis            \u2013 <p>Axis to squeeze. If <code>none</code>, all axes with dimension 1 are squeezed.</p> </li> </ul> <p> Returns </p> <p>New time-array object with squeezed_shape</p>"},{"location":"python_api/time_array/TimeArray.html#dynamiqs.time_array.TimeArray.__call__","title":"TimeArray.__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(t: ScalarLike) -&gt; Array\n</code></pre> <p>Returns the time-array evaluated at a given time.</p> <p> Parameters </p> <ul> <li> t            \u2013 <p>Time at which to evaluate the array.</p> </li> </ul> <p> Returns </p> <p>Array evaluated at time \\(t\\).</p>"},{"location":"python_api/time_array/constant.html","title":"constant","text":""},{"location":"python_api/time_array/constant.html#dynamiqs.time_array.constant","title":"dq.constant","text":"<pre><code>constant(array: ArrayLike) -&gt; ConstantTimeArray\n</code></pre> <p>Instantiate a constant time-array.</p> <p>A constant time-array is defined by \\(O(t) = O_0\\) for any time \\(t\\), where \\(O_0\\) is a constant array.</p> <p> Parameters </p> <ul> <li> array  (array_like of shape (..., n, n))                         \u2013 <p>Constant array \\(O_0\\).</p> </li> </ul> <p> Returns </p> <p>(time-array object of shape (..., n, n) when called) Callable object returning \\(O_0\\) for any time \\(t\\).</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; H = dq.constant(dq.sigmaz())\n&gt;&gt;&gt; H(0.0)\nArray([[ 1.+0.j,  0.+0.j],\n       [ 0.+0.j, -1.+0.j]], dtype=complex64)\n&gt;&gt;&gt; H(1.0)\nArray([[ 1.+0.j,  0.+0.j],\n       [ 0.+0.j, -1.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/time_array/modulated.html","title":"modulated","text":""},{"location":"python_api/time_array/modulated.html#dynamiqs.time_array.modulated","title":"dq.modulated","text":"<pre><code>modulated(\n    f: callable[[float], Scalar | Array],\n    array: ArrayLike,\n    *,\n    discontinuity_ts: ArrayLike | None = None\n) -&gt; ModulatedTimeArray\n</code></pre> <p>Instantiate a modulated time-array.</p> <p>A modulated time-array is defined by \\(O(t) = f(t) O_0\\) where \\(f(t)\\) is a time-dependent scalar. The function \\(f\\) is defined by passing a Python function with signature <code>f(t: float) -&gt; Scalar | Array</code> that returns a scalar or an array of shape (...) for any time \\(t\\).</p> <p> Parameters </p> <ul> <li> f  (function returning scalar or array of shape (...))                         \u2013 <p>Function with signature <code>f(t: float) -&gt; Scalar | Array</code> that returns the modulating factor \\(f(t)\\).</p> </li> <li> array  (array_like of shape (n, n))                         \u2013 <p>Constant array \\(O_0\\).</p> </li> <li> discontinuity_ts  (array_like, optional)                         \u2013 <p>Times at which there is a discontinuous jump in the function values.</p> </li> </ul> <p> Returns </p> <p>(time-array object of shape (..., n, n) when called) Callable object returning \\(O(t)\\) for any time \\(t\\).</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; f = lambda t: jnp.cos(2.0 * jnp.pi * t)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n&gt;&gt;&gt; H(0.5)\nArray([[-0.+0.j, -1.+0.j],\n       [-1.+0.j, -0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; H(1.0)\nArray([[0.+0.j, 1.+0.j],\n       [1.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/time_array/pwc.html","title":"pwc","text":""},{"location":"python_api/time_array/pwc.html#dynamiqs.time_array.pwc","title":"dq.pwc","text":"<pre><code>pwc(times: ArrayLike, values: ArrayLike, array: ArrayLike) -&gt; PWCTimeArray\n</code></pre> <p>Instantiate a piecewise constant (PWC) time-array.</p> <p>A PWC time-array takes constant values over some time intervals. It is defined by $$     O(t) = \\left(\\sum_{k=0}^{N-1} c_k\\; \\Omega_{[t_k, t_{k+1}[}(t)\\right) O_0 $$ where \\(c_k\\) are constant values, \\(\\Omega_{[t_k, t_{k+1}[}\\) is the rectangular window function defined by \\(\\Omega_{[t_a, t_b[}(t) = 1\\) if \\(t \\in [t_a, t_b[\\) and \\(\\Omega_{[t_a, t_b[}(t) = 0\\) otherwise, and \\(O_0\\) is a constant array.</p> Note <p>The argument <code>times</code> must be sorted in ascending order, but does not need to be evenly spaced.</p> Note <p>If the returned time-array is called for a time \\(t\\) which does not belong to any time intervals, the returned array is null.</p> <p> Parameters </p> <ul> <li> times  (array_like of shape (N+1,))                         \u2013 <p>Time points \\(t_k\\) defining the boundaries of the time intervals, where N is the number of time intervals.</p> </li> <li> values  (array_like of shape (..., N))                         \u2013 <p>Constant values \\(c_k\\) for each time interval.</p> </li> <li> array  (array_like of shape (n, n))                         \u2013 <p>Constant array \\(O_0\\).</p> </li> </ul> <p> Returns </p> <p>(time-array object of shape (..., n, n) when called) Callable object returning \\(O(t)\\) for any time \\(t\\).</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; times = [0.0, 1.0, 2.0]\n&gt;&gt;&gt; values = [3.0, -2.0]\n&gt;&gt;&gt; array = dq.sigmaz()\n&gt;&gt;&gt; H = dq.pwc(times, values, array)\n&gt;&gt;&gt; H(-0.5)\nArray([[ 0.+0.j,  0.+0.j],\n       [ 0.+0.j, -0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; H(0.0)\nArray([[ 3.+0.j,  0.+0.j],\n       [ 0.+0.j, -3.+0.j]], dtype=complex64)\n&gt;&gt;&gt; H(0.5)\nArray([[ 3.+0.j,  0.+0.j],\n       [ 0.+0.j, -3.+0.j]], dtype=complex64)\n&gt;&gt;&gt; H(1.0)\nArray([[-2.+0.j, -0.+0.j],\n       [-0.+0.j,  2.-0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/time_array/timecallable.html","title":"timecallable","text":""},{"location":"python_api/time_array/timecallable.html#dynamiqs.time_array.timecallable","title":"dq.timecallable","text":"<pre><code>timecallable(\n    f: callable[[float], Array], *, discontinuity_ts: ArrayLike | None = None\n) -&gt; CallableTimeArray\n</code></pre> <p>Instantiate a callable time-array.</p> <p>A callable time-array is defined by \\(O(t) = f(t)\\) where \\(f(t)\\) is a time-dependent operator. The function \\(f\\) is defined by passing a Python function with signature <code>f(t: float) -&gt; Array</code> that returns an array of shape (..., n, n) for any time \\(t\\).</p> The function <code>f</code> must return a JAX array (not an array-like object!) <p>An error is raised if the function <code>f</code> does not return a JAX array. This error concerns any other array-like objects. This is enforced to avoid costly conversions at every time step of the numerical integration.</p> <p> Parameters </p> <ul> <li> f  (function returning array of shape (..., n, n))                         \u2013 <p>Function with signature <code>(t: float) -&gt; Array</code> that returns the array \\(f(t)\\).</p> </li> <li> discontinuity_ts  (array_like, optional)                         \u2013 <p>Times at which there is a discontinuous jump in the function values.</p> </li> </ul> <p> Returns </p> <p>(time-array object of shape (..., n, n) when called) Callable object   returning \\(O(t)\\) for any time \\(t\\).</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; f = lambda t: jnp.array([[t, 0], [0, 1 - t]])\n&gt;&gt;&gt; H = dq.timecallable(f)\n&gt;&gt;&gt; H(0.5)\nArray([[0.5, 0. ],\n       [0. , 0.5]], dtype=float32)\n&gt;&gt;&gt; H(1.0)\nArray([[1., 0.],\n       [0., 0.]], dtype=float32)\n</code></pre>"},{"location":"python_api/utils/jax_utils/set_device.html","title":"set_device","text":""},{"location":"python_api/utils/jax_utils/set_device.html#dynamiqs.utils.jax_utils.set_device","title":"dq.set_device","text":"<pre><code>set_device(device: Literal['cpu', 'gpu', 'tpu'], index: int = 0)\n</code></pre> <p>Configure the default device.</p> Equivalent JAX syntax <p>This function is equivalent to <pre><code>jax.config.update('jax_default_device', jax.devices(device)[index])\n</code></pre></p> <p>See JAX documentation on devices.</p> <p> Parameters </p> <ul> <li> device  (string 'cpu', 'gpu', or 'tpu')                         \u2013 <p>Default device.</p> </li> <li> index            \u2013 <p>Index of the device to use, defaults to 0.</p> </li> </ul>"},{"location":"python_api/utils/jax_utils/set_matmul_precision.html","title":"set_matmul_precision","text":""},{"location":"python_api/utils/jax_utils/set_matmul_precision.html#dynamiqs.utils.jax_utils.set_matmul_precision","title":"dq.set_matmul_precision","text":"<pre><code>set_matmul_precision(matmul_precision: Literal['low', 'high', 'highest'])\n</code></pre> <p>Configure the default precision for matrix multiplications on GPUs and TPUs.</p> <p>Some devices allow trading off accuracy for speed when performing matrix multiplications (matmul). Three options are available:</p> <ul> <li><code>'low'</code> reduces matmul precision to <code>bfloat16</code> (fastest but least accurate),</li> <li><code>'high'</code> reduces matmul precision to <code>bfloat16_3x</code> or <code>tensorfloat32</code> if available     (faster but less accurate),</li> <li><code>'highest'</code> keeps matmul precision to <code>float32</code> or <code>float64</code> as applicable     (slowest but most accurate, default setting).</li> </ul> Equivalent JAX syntax <p>This function is equivalent to setting <code>jax_default_matmul_precision</code> in <code>jax.config</code>. See JAX documentation on matmul precision and JAX documentation on the different available options.</p> <p> Parameters </p> <ul> <li> matmul_precision  (string 'low', 'high', or 'highest')                         \u2013 <p>Default precision for matrix multiplications on GPUs and TPUs.</p> </li> </ul>"},{"location":"python_api/utils/jax_utils/set_precision.html","title":"set_precision","text":""},{"location":"python_api/utils/jax_utils/set_precision.html#dynamiqs.utils.jax_utils.set_precision","title":"dq.set_precision","text":"<pre><code>set_precision(precision: Literal['simple', 'double'])\n</code></pre> <p>Configure the default floating point precision.</p> <p>Two options are available:</p> <ul> <li><code>'simple'</code> sets default precision to <code>float32</code> and <code>complex64</code> (default setting),</li> <li><code>'double'</code> sets default precision to <code>float64</code> and <code>complex128</code>.</li> </ul> Equivalent JAX syntax <p>This function is equivalent to <pre><code>if precision == 'simple':\n    jax.config.update('jax_enable_x64', False)\nelif precision == 'double':\n    jax.config.update('jax_enable_x64', True)\n</code></pre>  See JAX documentation on double precision.</p> <p> Parameters </p> <ul> <li> precision  (string 'simple' or 'double')                         \u2013 <p>Default precision.</p> </li> </ul>"},{"location":"python_api/utils/jax_utils/to_qutip.html","title":"to_qutip","text":""},{"location":"python_api/utils/jax_utils/to_qutip.html#dynamiqs.utils.jax_utils.to_qutip","title":"dq.to_qutip","text":"<pre><code>to_qutip(x: ArrayLike, dims: tuple[int, ...] | None = None) -&gt; Qobj | list[Qobj]\n</code></pre> <p>Convert an array-like object into a QuTiP quantum object (or a list of QuTiP quantum objects if it has more than two dimensions).</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., 1, n) or (..., n, n))                         \u2013 <p>Ket, bra, density matrix or operator.</p> </li> <li> dims  (tuple of ints or None)                         \u2013 <p>Dimensions of each subsystem in the large Hilbert space of the composite system, defaults to <code>None</code> (a single system with the same dimension as <code>x</code>).</p> </li> </ul> <p> Returns </p> <p>QuTiP quantum object or list of QuTiP quantum objects.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psi = dq.fock(3, 1)\n&gt;&gt;&gt; psi\nArray([[0.+0.j],\n       [1.+0.j],\n       [0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.to_qutip(psi)\nQuantum object: dims=[[3], [1]], shape=(3, 1), type='ket', dtype=Dense\nQobj data =\n[[0.]\n [1.]\n [0.]]\n</code></pre> <p>For a batched array:</p> <pre><code>&gt;&gt;&gt; rhos = jnp.stack([dq.coherent_dm(16, i) for i in range(5)])\n&gt;&gt;&gt; rhos.shape\n(5, 16, 16)\n&gt;&gt;&gt; len(dq.to_qutip(rhos))\n5\n</code></pre> <p>Note that the tensor product structure is not inferred automatically, it must be specified with the <code>dims</code> argument:</p> <pre><code>&gt;&gt;&gt; I = dq.eye(3, 2)\n&gt;&gt;&gt; dq.to_qutip(I)\nQuantum object: dims=[[6], [6]], shape=(6, 6), type='oper', dtype=Dense, isherm=True\nQobj data =\n[[1. 0. 0. 0. 0. 0.]\n [0. 1. 0. 0. 0. 0.]\n [0. 0. 1. 0. 0. 0.]\n [0. 0. 0. 1. 0. 0.]\n [0. 0. 0. 0. 1. 0.]\n [0. 0. 0. 0. 0. 1.]]\n&gt;&gt;&gt; dq.to_qutip(I, (3, 2))\nQuantum object: dims=[[3, 2], [3, 2]], shape=(6, 6), type='oper', dtype=Dense, isherm=True\nQobj data =\n[[1. 0. 0. 0. 0. 0.]\n [0. 1. 0. 0. 0. 0.]\n [0. 0. 1. 0. 0. 0.]\n [0. 0. 0. 1. 0. 0.]\n [0. 0. 0. 0. 1. 0.]\n [0. 0. 0. 0. 0. 1.]]\n</code></pre>"},{"location":"python_api/utils/operators/cnot.html","title":"cnot","text":""},{"location":"python_api/utils/operators/cnot.html#dynamiqs.utils.operators.cnot","title":"dq.cnot","text":"<pre><code>cnot() -&gt; Array\n</code></pre> <p>Returns the \\(\\text{CNOT}\\) gate.</p> <p>It is defined by $$     \\text{CNOT} = \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 \\\\         0 &amp; 0 &amp; 1 &amp; 0     \\end{pmatrix} $$</p> <p> Returns </p> <p>(array of shape (4, 4)) \\(\\text{CNOT}\\) gate.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.cnot()\nArray([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/create.html","title":"create","text":""},{"location":"python_api/utils/operators/create.html#dynamiqs.utils.operators.create","title":"dq.create","text":"<pre><code>create(*dims: int) -&gt; Array | tuple[Array, ...]\n</code></pre> <p>Returns a bosonic creation operator, or a tuple of creation operators for a multi-mode system.</p> <p>If multiple dimensions are provided \\(\\mathtt{dims}=(n_1,\\dots,n_N)\\), it returns a tuple with len(dims) operators \\((A_1^\\dag,\\dots,A_N^\\dag)\\), where \\(A_k^\\dag\\) is the creation operator acting on the \\(k\\)-th subsystem within the composite Hilbert space of dimension \\(n=\\prod n_k\\): $$     A_k^\\dag = I_{n_1} \\otimes\\dots\\otimes a_{n_k}^\\dag \\otimes\\dots\\otimes I_{n_N}. $$</p> <p> Parameters </p> <ul> <li> *dims            \u2013 <p>Hilbert space dimension of each mode.</p> </li> </ul> <p> Returns </p> <p>(array or tuple of arrays, each of shape (n, n)) Creation operator(s), with n = prod(dims).</p> <p> Examples </p> <p>Single-mode \\(a^\\dag\\):</p> <pre><code>&gt;&gt;&gt; dq.create(4)\nArray([[0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j],\n       [1.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j],\n       [0.   +0.j, 1.414+0.j, 0.   +0.j, 0.   +0.j],\n       [0.   +0.j, 0.   +0.j, 1.732+0.j, 0.   +0.j]], dtype=complex64)\n</code></pre> <p>Multi-mode \\(a^\\dag\\otimes I_3\\) and \\(I_2\\otimes b^\\dag\\):</p> <pre><code>&gt;&gt;&gt; adag, bdag = dq.create(2, 3)\n&gt;&gt;&gt; adag\nArray([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; bdag\nArray([[0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j],\n       [1.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j],\n       [0.   +0.j, 1.414+0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j],\n       [0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j],\n       [0.   +0.j, 0.   +0.j, 0.   +0.j, 1.   +0.j, 0.   +0.j, 0.   +0.j],\n       [0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 1.414+0.j, 0.   +0.j]],      dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/destroy.html","title":"destroy","text":""},{"location":"python_api/utils/operators/destroy.html#dynamiqs.utils.operators.destroy","title":"dq.destroy","text":"<pre><code>destroy(*dims: int) -&gt; Array | tuple[Array, ...]\n</code></pre> <p>Returns a bosonic annihilation operator, or a tuple of annihilation operators for a multi-mode system.</p> <p>If multiple dimensions are provided \\(\\mathtt{dims}=(n_1,\\dots,n_N)\\), it returns a tuple with len(dims) operators \\((A_1,\\dots,A_N)\\), where \\(A_k\\) is the annihilation operator acting on the \\(k\\)-th subsystem within the composite Hilbert space of dimension \\(n=\\prod n_k\\): $$     A_k = I_{n_1} \\otimes\\dots\\otimes a_{n_k} \\otimes\\dots\\otimes I_{n_N}. $$</p> <p> Parameters </p> <ul> <li> *dims            \u2013 <p>Hilbert space dimension of each mode.</p> </li> </ul> <p> Returns </p> <p>(array or tuple of arrays, each of shape (n, n)) Annihilation operator(s), with n = prod(dims).</p> <p> Examples </p> <p>Single-mode \\(a\\):</p> <pre><code>&gt;&gt;&gt; dq.destroy(4)\nArray([[0.   +0.j, 1.   +0.j, 0.   +0.j, 0.   +0.j],\n       [0.   +0.j, 0.   +0.j, 1.414+0.j, 0.   +0.j],\n       [0.   +0.j, 0.   +0.j, 0.   +0.j, 1.732+0.j],\n       [0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j]], dtype=complex64)\n</code></pre> <p>Multi-mode \\(a\\otimes I_3\\) and \\(I_2\\otimes b\\):</p> <pre><code>&gt;&gt;&gt; a, b = dq.destroy(2, 3)\n&gt;&gt;&gt; a\nArray([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; b\nArray([[0.   +0.j, 1.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j],\n       [0.   +0.j, 0.   +0.j, 1.414+0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j],\n       [0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j],\n       [0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 1.   +0.j, 0.   +0.j],\n       [0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 1.414+0.j],\n       [0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j, 0.   +0.j]],      dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/displace.html","title":"displace","text":""},{"location":"python_api/utils/operators/displace.html#dynamiqs.utils.operators.displace","title":"dq.displace","text":"<pre><code>displace(dim: int, alpha: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the displacement operator of complex amplitude \\(\\alpha\\).</p> <p>It is defined by $$     D(\\alpha) = \\exp(\\alpha a^\\dag - \\alpha^* a), $$ where \\(a\\) and \\(a^\\dag\\) are the annihilation and creation operators, respectively.</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Dimension of the Hilbert space.</p> </li> <li> alpha  (array_like of shape (...))                         \u2013 <p>Displacement amplitude.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., dim, dim)) Displacement operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.displace(4, 0.5)\nArray([[ 0.882+0.j, -0.441+0.j,  0.156+0.j, -0.047+0.j],\n       [ 0.441+0.j,  0.662+0.j, -0.542+0.j,  0.27 +0.j],\n       [ 0.156+0.j,  0.542+0.j,  0.442+0.j, -0.697+0.j],\n       [ 0.047+0.j,  0.27 +0.j,  0.697+0.j,  0.662+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.displace(4, [0.1, 0.2]).shape\n(2, 4, 4)\n</code></pre>"},{"location":"python_api/utils/operators/eye.html","title":"eye","text":""},{"location":"python_api/utils/operators/eye.html#dynamiqs.utils.operators.eye","title":"dq.eye","text":"<pre><code>eye(*dims: int) -&gt; Array\n</code></pre> <p>Returns the identity operator.</p> <p>If multiple dimensions are provided \\(\\mathtt{dims}=(n_1,\\dots,n_N)\\), it returns the identity operator of the composite Hilbert space of dimension \\(n=\\prod n_k\\): $$     I_n = I_{n_1}\\otimes\\dots\\otimes I_{n_N}. $$</p> <p> Parameters </p> <ul> <li> *dims            \u2013 <p>Hilbert space dimension of each subsystem.</p> </li> </ul> <p> Returns </p> <p>(array of shape (n, n)) Identity operator, with n = prod(dims).</p> <p> Examples </p> <p>Single-mode \\(I_4\\):</p> <pre><code>&gt;&gt;&gt; dq.eye(4)\nArray([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]], dtype=complex64)\n</code></pre> <p>Multi-mode \\(I_2 \\otimes I_3\\):</p> <pre><code>&gt;&gt;&gt; dq.eye(2, 3)\nArray([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/hadamard.html","title":"hadamard","text":""},{"location":"python_api/utils/operators/hadamard.html#dynamiqs.utils.operators.hadamard","title":"dq.hadamard","text":"<pre><code>hadamard(n: int = 1) -&gt; Array\n</code></pre> <p>Returns the Hadamard transform on \\(n\\) qubits.</p> <p>For a single qubit, it is defined by $$     H = \\frac{1}{\\sqrt2} \\begin{pmatrix}         1 &amp; 1 \\\\         1 &amp; -1     \\end{pmatrix} $$ For \\(n\\) qubits, it is defined by the tensor product of Hadamard matrices: $$     H_n = \\bigotimes_{k=1}^n H $$</p> <p> Parameters </p> <ul> <li> n            \u2013 <p>Number of qubits to act on.</p> </li> </ul> <p> Returns </p> <p>(array of shape (2^n, 2^n)) Hadamard transform operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.hadamard()\nArray([[ 0.707+0.j,  0.707+0.j],\n       [ 0.707+0.j, -0.707+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.hadamard(2)\nArray([[ 0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j],\n       [ 0.5+0.j, -0.5+0.j,  0.5+0.j, -0.5+0.j],\n       [ 0.5+0.j,  0.5+0.j, -0.5+0.j, -0.5+0.j],\n       [ 0.5+0.j, -0.5+0.j, -0.5+0.j,  0.5-0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/momentum.html","title":"momentum","text":""},{"location":"python_api/utils/operators/momentum.html#dynamiqs.utils.operators.momentum","title":"dq.momentum","text":"<pre><code>momentum(dim: int) -&gt; Array\n</code></pre> <p>Returns the momentum operator \\(p = i (a^\\dag - a) / 2\\).</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Dimension of the Hilbert space.</p> </li> </ul> <p> Returns </p> <p>(array of shape (dim, dim)) Momentum operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.momentum(3)\nArray([[0.+0.j   , 0.-0.5j  , 0.+0.j   ],\n       [0.+0.5j  , 0.+0.j   , 0.-0.707j],\n       [0.+0.j   , 0.+0.707j, 0.+0.j   ]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/number.html","title":"number","text":""},{"location":"python_api/utils/operators/number.html#dynamiqs.utils.operators.number","title":"dq.number","text":"<pre><code>number(*dims: int) -&gt; Array | tuple[Array, ...]\n</code></pre> <p>Returns the number operator of a bosonic mode, or a tuple of number operators for a multi-mode system.</p> <p>For a single mode, it is defined by \\(N = a^\\dag a\\), where \\(a\\) and \\(a^\\dag\\) are the mode annihilation and creation operators, respectively. If multiple dimensions are provided \\(\\mathtt{dims}=(n_1,\\dots,n_M)\\), it returns a tuple with len(dims) operators \\((N_1,\\dots,N_M)\\), where \\(N_k\\) is the number operator acting on the \\(k\\)-th subsystem within the composite Hilbert space of dimension \\(n=\\prod n_k\\): $$     N_k = I_{n_1} \\otimes\\dots\\otimes a_{n_k}^\\dag a_{n_k} \\otimes\\dots\\otimes I_{n_M}. $$</p> <p> Parameters </p> <ul> <li> *dims            \u2013 <p>Hilbert space dimension of each mode.</p> </li> </ul> <p> Returns </p> <p>(array or tuple of arrays, each of shape (n, n)) Number operator(s), with n = prod(dims).</p> <p> Examples </p> <p>Single-mode \\(a^\\dag a\\):</p> <pre><code>&gt;&gt;&gt; dq.number(4)\nArray([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 2.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 3.+0.j]], dtype=complex64)\n</code></pre> <p>Multi-mode \\(a^\\dag a \\otimes I_3\\) and \\(I_2\\otimes b^\\dag b\\):</p> <pre><code>&gt;&gt;&gt; na, nb = dq.number(2, 3)\n&gt;&gt;&gt; na\nArray([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]], dtype=complex64)\n&gt;&gt;&gt; nb\nArray([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 2.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 2.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/parity.html","title":"parity","text":""},{"location":"python_api/utils/operators/parity.html#dynamiqs.utils.operators.parity","title":"dq.parity","text":"<pre><code>parity(dim: int) -&gt; Array\n</code></pre> <p>Returns the parity operator of a bosonic mode.</p> <p>It is defined by \\(P = e^{i\\pi a^\\dag a}\\), where \\(a\\) and \\(a^\\dag\\) are the annihilation and creation operators, respectively.</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Dimension of the Hilbert space.</p> </li> </ul> <p> Returns </p> <p>(array of shape (dim, dim)) Parity operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.parity(4)\nArray([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j, -1.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  0.+0.j, -1.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/position.html","title":"position","text":""},{"location":"python_api/utils/operators/position.html#dynamiqs.utils.operators.position","title":"dq.position","text":"<pre><code>position(dim: int) -&gt; Array\n</code></pre> <p>Returns the position operator \\(x = (a^\\dag + a) / 2\\).</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Dimension of the Hilbert space.</p> </li> </ul> <p> Returns </p> <p>(array of shape (dim, dim)) Position operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.position(3)\nArray([[0.   +0.j, 0.5  +0.j, 0.   +0.j],\n       [0.5  +0.j, 0.   +0.j, 0.707+0.j],\n       [0.   +0.j, 0.707+0.j, 0.   +0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/quadrature.html","title":"quadrature","text":""},{"location":"python_api/utils/operators/quadrature.html#dynamiqs.utils.operators.quadrature","title":"dq.quadrature","text":"<pre><code>quadrature(dim: int, phi: float) -&gt; Array\n</code></pre> <p>Returns the quadrature operator of phase angle \\(\\phi\\).</p> <p>It is defined by \\(x_\\phi = (e^{i\\phi} a^\\dag + e^{-i\\phi} a) / 2\\), where \\(a\\) and \\(a^\\dag\\) are the annihilation and creation operators respectively.</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Dimension of the Hilbert space.</p> </li> <li> phi            \u2013 <p>Phase angle.</p> </li> </ul> <p> Returns </p> <p>(array of shape (dim, dim)) Quadrature operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.quadrature(3, 0.0)\nArray([[0.   +0.j, 0.5  +0.j, 0.   +0.j],\n       [0.5  +0.j, 0.   +0.j, 0.707+0.j],\n       [0.   +0.j, 0.707+0.j, 0.   +0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.quadrature(3, jnp.pi / 2)\nArray([[ 0.+0.j   , -0.-0.5j  ,  0.+0.j   ],\n       [-0.+0.5j  ,  0.+0.j   , -0.-0.707j],\n       [ 0.+0.j   , -0.+0.707j,  0.+0.j   ]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/rx.html","title":"rx","text":""},{"location":"python_api/utils/operators/rx.html#dynamiqs.utils.operators.rx","title":"dq.rx","text":"<pre><code>rx(theta: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the \\(R_x(\\theta)\\) rotation gate.</p> <p>It is defined by $$     R_x(\\theta) = \\begin{pmatrix}         \\cos(\\theta/2)   &amp; -i\\sin(\\theta/2) \\\\         -i\\sin(\\theta/2) &amp; \\cos(\\theta/2)     \\end{pmatrix} $$</p> <p> Parameters </p> <ul> <li> theta  (array_like of shape (...))                         \u2013 <p>Rotation angle \\(\\theta\\) in radians.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., 2, 2)) \\(R_x(\\theta)\\) gate.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.rx(jnp.pi)\nArray([[-0.+0.j,  0.-1.j],\n       [ 0.-1.j, -0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.rx([0, jnp.pi/4, jnp.pi/3, jnp.pi/2, jnp.pi]).shape\n(5, 2, 2)\n</code></pre>"},{"location":"python_api/utils/operators/ry.html","title":"ry","text":""},{"location":"python_api/utils/operators/ry.html#dynamiqs.utils.operators.ry","title":"dq.ry","text":"<pre><code>ry(theta: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the \\(R_y(\\theta)\\) rotation gate.</p> <p>It is defined by $$     R_y(\\theta) = \\begin{pmatrix}         \\cos(\\theta/2) &amp; -\\sin(\\theta/2) \\\\         \\sin(\\theta/2) &amp; \\cos(\\theta/2)     \\end{pmatrix} $$</p> <p> Parameters </p> <ul> <li> theta  (array_like of shape (...))                         \u2013 <p>Rotation angle \\(\\theta\\) in radians.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., 2, 2)) \\(R_y(\\theta)\\) gate.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.ry(jnp.pi)\nArray([[-0.+0.j, -1.+0.j],\n       [ 1.+0.j, -0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.ry([0, jnp.pi/4, jnp.pi/3, jnp.pi/2, jnp.pi]).shape\n(5, 2, 2)\n</code></pre>"},{"location":"python_api/utils/operators/rz.html","title":"rz","text":""},{"location":"python_api/utils/operators/rz.html#dynamiqs.utils.operators.rz","title":"dq.rz","text":"<pre><code>rz(theta: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the \\(R_z(\\theta)\\) rotation gate.</p> <p>It is defined by $$     R_z(\\theta) = \\begin{pmatrix}         e^{-i\\theta/2} &amp; 0 \\\\         0              &amp; e^{i\\theta/2}     \\end{pmatrix} $$</p> <p> Parameters </p> <ul> <li> theta  (array_like of shape (...))                         \u2013 <p>Rotation angle \\(\\theta\\) in radians.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., 2, 2)) \\(R_z(\\theta)\\) gate.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.rz(jnp.pi)\nArray([[-0.-1.j,  0.+0.j],\n       [ 0.+0.j, -0.+1.j]], dtype=complex64)\n&gt;&gt;&gt; dq.rz([0, jnp.pi/4, jnp.pi/3, jnp.pi/2, jnp.pi]).shape\n(5, 2, 2)\n</code></pre>"},{"location":"python_api/utils/operators/sgate.html","title":"sgate","text":""},{"location":"python_api/utils/operators/sgate.html#dynamiqs.utils.operators.sgate","title":"dq.sgate","text":"<pre><code>sgate() -&gt; Array\n</code></pre> <p>Returns the \\(\\text{S}\\) gate.</p> <p>It is defined by \\(\\text{S} = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; i \\end{pmatrix}\\).</p> <p> Returns </p> <p>(array of shape (2, 2)) \\(\\text{S}\\) gate.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.sgate()\nArray([[1.+0.j, 0.+0.j],\n       [0.+0.j, 0.+1.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/sigmam.html","title":"sigmam","text":""},{"location":"python_api/utils/operators/sigmam.html#dynamiqs.utils.operators.sigmam","title":"dq.sigmam","text":"<pre><code>sigmam() -&gt; Array\n</code></pre> <p>Returns the Pauli lowering operator \\(\\sigma_-\\).</p> <p>It is defined by \\(\\sigma_- = \\begin{pmatrix} 0 &amp; 0 \\\\ 1 &amp; 0 \\end{pmatrix}\\).</p> <p> Returns </p> <p>(array of shape (2, 2)) Pauli \\(\\sigma_-\\) operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.sigmam()\nArray([[0.+0.j, 0.+0.j],\n       [1.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/sigmap.html","title":"sigmap","text":""},{"location":"python_api/utils/operators/sigmap.html#dynamiqs.utils.operators.sigmap","title":"dq.sigmap","text":"<pre><code>sigmap() -&gt; Array\n</code></pre> <p>Returns the Pauli raising operator \\(\\sigma_+\\).</p> <p>It is defined by \\(\\sigma_+ = \\begin{pmatrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\end{pmatrix}\\).</p> <p> Returns </p> <p>(array of shape (2, 2)) Pauli \\(\\sigma_+\\) operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.sigmap()\nArray([[0.+0.j, 1.+0.j],\n       [0.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/sigmax.html","title":"sigmax","text":""},{"location":"python_api/utils/operators/sigmax.html#dynamiqs.utils.operators.sigmax","title":"dq.sigmax","text":"<pre><code>sigmax() -&gt; Array\n</code></pre> <p>Returns the Pauli \\(\\sigma_x\\) operator.</p> <p>It is defined by \\(\\sigma_x = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}\\).</p> <p> Returns </p> <p>(array of shape (2, 2)) Pauli \\(\\sigma_x\\) operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.sigmax()\nArray([[0.+0.j, 1.+0.j],\n       [1.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/sigmay.html","title":"sigmay","text":""},{"location":"python_api/utils/operators/sigmay.html#dynamiqs.utils.operators.sigmay","title":"dq.sigmay","text":"<pre><code>sigmay() -&gt; Array\n</code></pre> <p>Returns the Pauli \\(\\sigma_y\\) operator.</p> <p>It is defined by \\(\\sigma_y = \\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{pmatrix}\\).</p> <p> Returns </p> <p>(array of shape (2, 2)) Pauli \\(\\sigma_y\\) operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.sigmay()\nArray([[ 0.+0.j, -0.-1.j],\n       [ 0.+1.j,  0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/sigmaz.html","title":"sigmaz","text":""},{"location":"python_api/utils/operators/sigmaz.html#dynamiqs.utils.operators.sigmaz","title":"dq.sigmaz","text":"<pre><code>sigmaz() -&gt; Array\n</code></pre> <p>Returns the Pauli \\(\\sigma_z\\) operator.</p> <p>It is defined by \\(\\sigma_z = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{pmatrix}\\).</p> <p> Returns </p> <p>(array of shape (2, 2)) Pauli \\(\\sigma_z\\) operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.sigmaz()\nArray([[ 1.+0.j,  0.+0.j],\n       [ 0.+0.j, -1.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/squeeze.html","title":"squeeze","text":""},{"location":"python_api/utils/operators/squeeze.html#dynamiqs.utils.operators.squeeze","title":"dq.squeeze","text":"<pre><code>squeeze(dim: int, z: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the squeezing operator of complex squeezing amplitude \\(z\\).</p> <p>It is defined by $$     S(z) = \\exp\\left(\\frac{1}{2}\\left(z^* a^2 - z a^{\\dag 2}\\right)\\right), $$ where \\(a\\) and \\(a^\\dag\\) are the annihilation and creation operators, respectively.</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Dimension of the Hilbert space.</p> </li> <li> z  (array_like of shape (...))                         \u2013 <p>Squeezing amplitude.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., dim, dim)) Squeezing operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.squeeze(4, 0.5)\nArray([[ 0.938+0.j,  0.   +0.j,  0.346+0.j,  0.   +0.j],\n       [ 0.   +0.j,  0.818+0.j,  0.   +0.j,  0.575+0.j],\n       [-0.346+0.j,  0.   +0.j,  0.938+0.j,  0.   +0.j],\n       [ 0.   +0.j, -0.575+0.j,  0.   +0.j,  0.818+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.squeeze(4, [0.1, 0.2]).shape\n(2, 4, 4)\n</code></pre>"},{"location":"python_api/utils/operators/tgate.html","title":"tgate","text":""},{"location":"python_api/utils/operators/tgate.html#dynamiqs.utils.operators.tgate","title":"dq.tgate","text":"<pre><code>tgate() -&gt; Array\n</code></pre> <p>Returns the \\(\\text{T}\\) gate.</p> <p>It is defined by \\(\\text{T} = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\frac{\\pi}{4}} \\end{pmatrix}\\).</p> <p> Returns </p> <p>(array of shape (2, 2)) \\(\\text{T}\\) gate.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.tgate()\nArray([[1.   +0.j   , 0.   +0.j   ],\n       [0.   +0.j   , 0.707+0.707j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/toffoli.html","title":"toffoli","text":""},{"location":"python_api/utils/operators/toffoli.html#dynamiqs.utils.operators.toffoli","title":"dq.toffoli","text":"<pre><code>toffoli() -&gt; Array\n</code></pre> <p>Returns the \\(\\text{Toffoli}\\) gate.</p> <p>It is defined by $$     \\text{Toffoli} = \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0     \\end{pmatrix} $$</p> <p> Returns </p> <p>(array of shape (8, 8)) \\(\\text{Toffoli}\\) gate.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.toffoli()\nArray([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]],      dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/operators/zero.html","title":"zero","text":""},{"location":"python_api/utils/operators/zero.html#dynamiqs.utils.operators.zero","title":"dq.zero","text":"<pre><code>zero(*dims: int) -&gt; Array\n</code></pre> <p>Returns the null operator.</p> <p>If multiple dimensions are provided \\(\\mathtt{dims}=(n_1,\\dots,n_N)\\), it returns the null operator of the composite Hilbert space of dimension \\(n=\\prod n_k\\): $$     0_n = 0_{n_1}\\otimes\\dots\\otimes 0_{n_N}. $$</p> <p> Parameters </p> <ul> <li> *dims            \u2013 <p>Hilbert space dimension of each subsystem.</p> </li> </ul> <p> Returns </p> <p>(array of shape (n, n)) Null operator, with n = prod(dims).</p> <p> Examples </p> <p>Single-mode \\(0_4\\):</p> <pre><code>&gt;&gt;&gt; dq.zero(4)\nArray([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre> <p>Multi-mode \\(0_2 \\otimes 0_3\\):</p> <pre><code>&gt;&gt;&gt; dq.zero(2, 3)\nArray([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/optimal_control/cd_gate.html","title":"cd_gate","text":""},{"location":"python_api/utils/optimal_control/cd_gate.html#dynamiqs.utils.optimal_control.cd_gate","title":"dq.cd_gate","text":"<pre><code>cd_gate(dim: int, alpha: ArrayLike) -&gt; Array\n</code></pre> <p>Returns a conditional displacement gate.</p> <p>The conditional displacement (CD) gate displaces an oscillator conditioned on the state of a coupled two-level system (TLS) state. It is defined by $$    \\mathrm{CD}(\\alpha) = D(\\alpha/2)\\ket{g}\\bra{g} + D(-\\alpha/2)\\ket{e}\\bra{e}, $$ where \\(\\ket{g}=\\ket0\\) and \\(\\ket{e}=\\ket1\\) are the ground and excited states of the TLS, respectively.</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Dimension of the oscillator Hilbert space.</p> </li> <li> alpha  (array_like of shape (...))                         \u2013 <p>Displacement amplitude.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) CD gate operator (acting on the oscillator + TLS system of dimension n = 2 x dim).</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.cd_gate(2, 0.1)\nArray([[ 0.999+0.j,  0.   +0.j, -0.05 +0.j,  0.   +0.j],\n       [ 0.   +0.j,  0.999+0.j,  0.   +0.j,  0.05 +0.j],\n       [ 0.05 +0.j,  0.   +0.j,  0.999+0.j,  0.   +0.j],\n       [ 0.   +0.j, -0.05 +0.j,  0.   +0.j,  0.999+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.cd_gate(3, [0.1, 0.2]).shape\n(2, 6, 6)\n</code></pre>"},{"location":"python_api/utils/optimal_control/snap_gate.html","title":"snap_gate","text":""},{"location":"python_api/utils/optimal_control/snap_gate.html#dynamiqs.utils.optimal_control.snap_gate","title":"dq.snap_gate","text":"<pre><code>snap_gate(phase: ArrayLike) -&gt; Array\n</code></pre> <p>Returns a SNAP gate.</p> <p>The selective number-dependent arbitrary phase (SNAP) gate imparts a different phase \\(\\theta_k\\) to each Fock state \\(\\ket{k}\\bra{k}\\). It is defined by $$     \\mathrm{SNAP}(\\theta_0,\\dots,\\theta_{n-1}) =     \\sum_{k=0}^{n-1} e^{i\\theta_k} \\ket{k}\\bra{k}. $$</p> <p> Parameters </p> <ul> <li> phase  (array_like of shape (..., n))                         \u2013 <p>Phase for each Fock state. The last dimension of the array n defines the Hilbert space dimension.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) SNAP gate operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.snap_gate([0, 1, 2])\nArray([[ 1.   +0.j   ,  0.   +0.j   ,  0.   +0.j   ],\n       [ 0.   +0.j   ,  0.54 +0.841j,  0.   +0.j   ],\n       [ 0.   +0.j   ,  0.   +0.j   , -0.416+0.909j]], dtype=complex64)\n&gt;&gt;&gt; dq.snap_gate([[0, 1, 2], [2, 3, 4]]).shape\n(2, 3, 3)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/bloch_coordinates.html","title":"bloch_coordinates","text":""},{"location":"python_api/utils/quantum_utils/bloch_coordinates.html#dynamiqs.utils.quantum_utils.bloch_coordinates","title":"dq.bloch_coordinates","text":"<pre><code>bloch_coordinates(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the spherical coordinates \\((r, \\theta, \\phi)\\) of a ket or density matrix on the Bloch sphere.</p> <p>The coordinates are such that $$     \\begin{cases}         0\\leq r \\leq 1, \\\\         0\\leq\\theta\\leq\\pi, \\\\         0\\leq\\phi&lt;2\\pi.     \\end{cases} $$</p> <p>By convention, we choose \\(\\phi=0\\) if \\(\\theta=0\\), and \\(\\theta=\\phi=0\\) if \\(r=0\\).</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (2, 1) or (2, 2))                         \u2013 <p>Ket or density matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (3,)) Spherical coordinates \\((r, \\theta, \\phi)\\).</p> <p> Examples </p> <p>The state \\(\\ket0\\) is on the north pole at coordinates \\((r,\\theta,\\phi) = (1,0,0)\\):</p> <pre><code>&gt;&gt;&gt; x = dq.basis(2, 0)\n&gt;&gt;&gt; dq.bloch_coordinates(x)\nArray([1., 0., 0.], dtype=float32)\n</code></pre> <p>The state \\(\\ket1\\) is on the south pole at coordinates \\((r,\\theta,\\phi) = (1,\\pi,0)\\):</p> <pre><code>&gt;&gt;&gt; x = dq.basis(2, 1)\n&gt;&gt;&gt; dq.bloch_coordinates(x)\nArray([1.   , 3.142, 0.   ], dtype=float32)\n</code></pre> <p>The state \\(\\ket+=(\\ket0+\\ket1)/\\sqrt2\\) is aligned with the \\(x\\)-axis at coordinates \\((r,\\theta,\\phi) = (1,\\pi/2,0)\\):</p> <pre><code>&gt;&gt;&gt; plus = dq.unit(dq.basis(2, 0) + dq.basis(2, 1))\n&gt;&gt;&gt; dq.bloch_coordinates(plus)\nArray([1.   , 1.571, 0.   ], dtype=float32)\n</code></pre> <p>The state \\(\\ket-=(\\ket0-\\ket1)/\\sqrt2\\) is aligned with the \\(-x\\)-axis at coordinates \\((r,\\theta,\\phi) = (1,\\pi/2,\\pi)\\):</p> <pre><code>&gt;&gt;&gt; minus = dq.unit(dq.basis(2, 0) - dq.basis(2, 1))\n&gt;&gt;&gt; dq.bloch_coordinates(minus)\nArray([1.   , 1.571, 3.142], dtype=float32)\n</code></pre> <p>A fully mixed state \\(\\rho=0.5\\ket0\\bra0+0.5\\ket1\\bra1\\) is at the center of the sphere at coordinates \\((r,\\theta,\\phi) = (0,0,0)\\):</p> <pre><code>&gt;&gt;&gt; x = 0.5 * dq.basis_dm(2, 0) + 0.5 * dq.basis_dm(2, 1)\n&gt;&gt;&gt; dq.bloch_coordinates(x)\nArray([0., 0., 0.], dtype=float32)\n</code></pre> <p>A partially mixed state \\(\\rho=0.75\\ket0\\bra0 + 0.25\\ket1\\bra1\\) is halfway between the sphere center and the north pole at coordinates \\((r,\\theta,\\phi) = (0.5,0,0)\\):</p> <pre><code>&gt;&gt;&gt; x = 0.75 * dq.basis_dm(2, 0) + 0.25 * dq.basis_dm(2, 1)\n&gt;&gt;&gt; dq.bloch_coordinates(x)\nArray([0.5, 0. , 0. ], dtype=float32)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/braket.html","title":"braket","text":""},{"location":"python_api/utils/quantum_utils/braket.html#dynamiqs.utils.quantum_utils.braket","title":"dq.braket","text":"<pre><code>braket(x: ArrayLike, y: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the inner product \\(\\braket{\\psi|\\varphi}\\) between two kets.</p> <p> Parameters </p> <ul> <li> x            \u2013 <p>Left-side ket.</p> </li> <li> y            \u2013 <p>Right-side ket.</p> </li> </ul> <p> Returns </p> <p>(array of shape (...)) Complex-valued inner product.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; fock0 = dq.fock(3, 0)\n&gt;&gt;&gt; fock01 = dq.unit(dq.fock(3, 0) + dq.fock(3, 1))\n&gt;&gt;&gt; dq.braket(fock0, fock01)\nArray(0.707+0.j, dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/cosm.html","title":"cosm","text":""},{"location":"python_api/utils/quantum_utils/cosm.html#dynamiqs.utils.quantum_utils.cosm","title":"dq.cosm","text":"<pre><code>cosm(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the cosine of an array.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Square matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Cosine of <code>x</code>.</p> Note <p>This function uses <code>jax.scipy.linalg.expm()</code> to compute the cosine of a matrix \\(A\\): $$     \\cos(A) = \\frac{e^{iA} + e^{-iA}}{2} $$</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.cosm(jnp.pi * dq.sigmax())\nArray([[-1.+0.j,  0.+0.j],\n       [ 0.+0.j, -1.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/dag.html","title":"dag","text":""},{"location":"python_api/utils/quantum_utils/dag.html#dynamiqs.utils.quantum_utils.dag","title":"dq.dag","text":"<pre><code>dag(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the adjoint (complex conjugate transpose) of a matrix.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., m, n))                         \u2013 <p>Matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, m)) Adjoint of <code>x</code>.</p> Equivalent JAX syntax <p>This function is equivalent to <code>x.mT.conj()</code>.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.fock(2, 0)\nArray([[1.+0.j],\n       [0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.dag(dq.fock(2, 0))\nArray([[1.-0.j, 0.-0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/dissipator.html","title":"dissipator","text":""},{"location":"python_api/utils/quantum_utils/dissipator.html#dynamiqs.utils.quantum_utils.dissipator","title":"dq.dissipator","text":"<pre><code>dissipator(L: ArrayLike, rho: ArrayLike) -&gt; Array\n</code></pre> <p>Applies the Lindblad dissipation superoperator to a density matrix.</p> <p>The dissipation superoperator \\(\\mathcal{D}[L]\\) is defined by: $$     \\mathcal{D}[L] (\\rho) = L\\rho L^\\dag - \\frac{1}{2}L^\\dag L \\rho     - \\frac{1}{2}\\rho L^\\dag L. $$</p> <p> Parameters </p> <ul> <li> L  (array_like of shape (..., n, n))                         \u2013 <p>Jump operator.</p> </li> <li> rho  (array_like of shape (..., n, n))                         \u2013 <p>Density matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Resulting operator (it is not a density matrix).</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; L = dq.destroy(4)\n&gt;&gt;&gt; rho = dq.fock_dm(4, 2)\n&gt;&gt;&gt; dq.dissipator(L, rho)\nArray([[ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  2.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j, -2.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/entropy_vn.html","title":"entropy_vn","text":""},{"location":"python_api/utils/quantum_utils/entropy_vn.html#dynamiqs.utils.quantum_utils.entropy_vn","title":"dq.entropy_vn","text":"<pre><code>entropy_vn(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the Von Neumann entropy of a ket or density matrix.</p> <p>It is defined by \\(S(\\rho) = -\\tr{\\rho \\ln \\rho}\\).</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., n, n))                         \u2013 <p>Ket or density matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (...)) Real-valued Von Neumann entropy.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; rho = dq.unit(dq.fock_dm(2, 0) + dq.fock_dm(2, 1))\n&gt;&gt;&gt; dq.entropy_vn(rho)\nArray(0.693, dtype=float32)\n&gt;&gt;&gt; psis = [dq.fock(16, i) for i in range(5)]\n&gt;&gt;&gt; dq.entropy_vn(psis).shape\n(5,)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/expect.html","title":"expect","text":""},{"location":"python_api/utils/quantum_utils/expect.html#dynamiqs.utils.quantum_utils.expect","title":"dq.expect","text":"<pre><code>expect(O: ArrayLike, x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the expectation value of an operator or list of operators on a ket, bra or density matrix.</p> <p>The expectation value \\(\\braket{O}\\) of an operator \\(O\\) is computed</p> <ul> <li>as \\(\\braket{O}=\\braket{\\psi|O|\\psi}\\) if <code>x</code> is a ket \\(\\ket\\psi\\) or bra \\(\\bra\\psi\\),</li> <li>as \\(\\braket{O}=\\tr{O\\rho}\\) if <code>x</code> is a density matrix \\(\\rho\\).</li> </ul> Warning <p>The returned array is complex-valued. If the operator \\(O\\) corresponds to a physical observable, it is Hermitian: \\(O^\\dag=O\\), and the expectation value is real. One can then keep only the real values of the returned array using <code>dq.expect(O, x).real</code>.</p> <p> Parameters </p> <ul> <li> O  (array_like of shape (nO?, n, n))                         \u2013 <p>Arbitrary operator or list of nO operators.</p> </li> <li> x  (array_like of shape (..., n, 1) or (..., 1, n) or (..., n, n))                         \u2013 <p>Ket, bra or density matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (nO?, ...)) Complex-valued expectation value.</p> <p> Raises </p> <ul> <li> <code> ValueError </code>             \u2013           <p>If <code>x</code> is not a ket, bra or density matrix.</p> </li> </ul> <p> Examples </p> <pre><code>&gt;&gt;&gt; O = dq.number(16)\n&gt;&gt;&gt; psi = dq.coherent(16, 2.0)\n&gt;&gt;&gt; dq.expect(O, psi)\nArray(4.+0.j, dtype=complex64)\n&gt;&gt;&gt; psis = [dq.fock(16, i) for i in range(5)]\n&gt;&gt;&gt; dq.expect(O, psis).shape\n(5,)\n&gt;&gt;&gt; Os = [dq.position(16), dq.momentum(16)]\n&gt;&gt;&gt; dq.expect(Os, psis).shape\n(2, 5)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/expm.html","title":"expm","text":""},{"location":"python_api/utils/quantum_utils/expm.html#dynamiqs.utils.quantum_utils.expm","title":"dq.expm","text":"<pre><code>expm(x: ArrayLike, *, max_squarings: int = 16) -&gt; Array\n</code></pre> <p>Returns the matrix exponential of an array.</p> <p>The exponential is computed using the scaling-and-squaring approximation method.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Square matrix.</p> </li> <li> max_squarings            \u2013 <p>Number of squarings.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Matrix exponential of <code>x</code>.</p> Equivalent JAX syntax <p>This function is equivalent to <code>jnp.scipy.linalg.expm(x, max_squarings=max_squarings)</code>.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.expm(dq.sigmaz())\nArray([[2.718+0.j, 0.   +0.j],\n       [0.   +0.j, 0.368+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/fidelity.html","title":"fidelity","text":""},{"location":"python_api/utils/quantum_utils/fidelity.html#dynamiqs.utils.quantum_utils.fidelity","title":"dq.fidelity","text":"<pre><code>fidelity(x: ArrayLike, y: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the fidelity of two states, kets or density matrices.</p> <p>The fidelity is computed</p> <ul> <li>as \\(F(\\ket\\psi,\\ket\\varphi)=\\left|\\braket{\\psi|\\varphi}\\right|^2\\) if both   arguments are kets,</li> <li>as \\(F(\\ket\\psi,\\rho)=\\lvert\\braket{\\psi|\\rho|\\psi}\\rvert\\) if one arguments is a   ket and the other is a density matrix,</li> <li>as \\(F(\\rho,\\sigma)=\\tr{\\sqrt{\\sqrt\\rho\\sigma\\sqrt\\rho}}^2\\) if both arguments are   density matrices.</li> </ul> Warning <p>This definition is different from <code>qutip.fidelity()</code> which uses the square root fidelity \\(F_\\text{qutip} = \\sqrt{F}\\).</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., n, n))                         \u2013 <p>Ket or density matrix.</p> </li> <li> y  (array_like of shape (..., n, 1) or (..., n, n))                         \u2013 <p>Ket or density matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (...)) Real-valued fidelity.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; fock0 = dq.fock(3, 0)\n&gt;&gt;&gt; dq.fidelity(fock0, fock0)\nArray(1., dtype=float32)\n&gt;&gt;&gt; fock01_dm = 0.5 * (dq.fock_dm(3, 1) + dq.fock_dm(3, 0))\n&gt;&gt;&gt; dq.fidelity(fock01_dm, fock01_dm)\nArray(1., dtype=float32)\n&gt;&gt;&gt; dq.fidelity(fock0, fock01_dm)\nArray(0.5, dtype=float32)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/isbra.html","title":"isbra","text":""},{"location":"python_api/utils/quantum_utils/isbra.html#dynamiqs.utils.quantum_utils.isbra","title":"dq.isbra","text":"<pre><code>isbra(x: ArrayLike) -&gt; bool\n</code></pre> <p>Returns True if the array is in the format of a bra.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (...))                         \u2013 <p>Array.</p> </li> </ul> <p> Returns </p> <p>True if the second to last dimension of <code>x</code> is 1, False otherwise.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.isbra(jnp.ones((1, 3)))\nTrue\n&gt;&gt;&gt; dq.isbra(jnp.ones((5, 1, 3)))\nTrue\n&gt;&gt;&gt; dq.isbra(jnp.ones((3, 3)))\nFalse\n</code></pre>"},{"location":"python_api/utils/quantum_utils/isdm.html","title":"isdm","text":""},{"location":"python_api/utils/quantum_utils/isdm.html#dynamiqs.utils.quantum_utils.isdm","title":"dq.isdm","text":"<pre><code>isdm(x: ArrayLike) -&gt; bool\n</code></pre> <p>Returns True if the array is in the format of a density matrix.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (...))                         \u2013 <p>Array.</p> </li> </ul> <p> Returns </p> <p>True if the last two dimensions of <code>x</code> are equal, False otherwise.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.isdm(jnp.ones((3, 3)))\nTrue\n&gt;&gt;&gt; dq.isdm(jnp.ones((5, 3, 3)))\nTrue\n&gt;&gt;&gt; dq.isdm(jnp.ones((3, 1)))\nFalse\n</code></pre>"},{"location":"python_api/utils/quantum_utils/isherm.html","title":"isherm","text":""},{"location":"python_api/utils/quantum_utils/isherm.html#dynamiqs.utils.quantum_utils.isherm","title":"dq.isherm","text":"<pre><code>isherm(x: ArrayLike, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Returns True if the array is Hermitian.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Array.</p> </li> <li> rtol            \u2013 <p>Relative tolerance of the check.</p> </li> <li> atol            \u2013 <p>Absolute tolerance of the check.</p> </li> </ul> <p> Returns </p> <p>True if <code>x</code> is Hermitian, False otherwise.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.isherm(jnp.eye(3))\nArray(True, dtype=bool)\n&gt;&gt;&gt; dq.isherm([[0, 1j], [1j, 0]])\nArray(False, dtype=bool)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/isket.html","title":"isket","text":""},{"location":"python_api/utils/quantum_utils/isket.html#dynamiqs.utils.quantum_utils.isket","title":"dq.isket","text":"<pre><code>isket(x: ArrayLike) -&gt; bool\n</code></pre> <p>Returns True if the array is in the format of a ket.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (...))                         \u2013 <p>Array.</p> </li> </ul> <p> Returns </p> <p>True if the last dimension of <code>x</code> is 1, False otherwise.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.isket(jnp.ones((3, 1)))\nTrue\n&gt;&gt;&gt; dq.isket(jnp.ones((5, 3, 1)))\nTrue\n&gt;&gt;&gt; dq.isket(jnp.ones((3, 3)))\nFalse\n</code></pre>"},{"location":"python_api/utils/quantum_utils/isop.html","title":"isop","text":""},{"location":"python_api/utils/quantum_utils/isop.html#dynamiqs.utils.quantum_utils.isop","title":"dq.isop","text":"<pre><code>isop(x: ArrayLike) -&gt; bool\n</code></pre> <p>Returns True if the array is in the format of an operator.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (...))                         \u2013 <p>Array.</p> </li> </ul> <p> Returns </p> <p>True if the last two dimensions of <code>x</code> are equal, False otherwise.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.isop(jnp.ones((3, 3)))\nTrue\n&gt;&gt;&gt; dq.isop(jnp.ones((5, 3, 3)))\nTrue\n&gt;&gt;&gt; dq.isop(jnp.ones((3, 1)))\nFalse\n</code></pre>"},{"location":"python_api/utils/quantum_utils/lindbladian.html","title":"lindbladian","text":""},{"location":"python_api/utils/quantum_utils/lindbladian.html#dynamiqs.utils.quantum_utils.lindbladian","title":"dq.lindbladian","text":"<pre><code>lindbladian(H: ArrayLike, jump_ops: ArrayLike, rho: ArrayLike) -&gt; Array\n</code></pre> <p>Applies the Lindbladian superoperator to a density matrix.</p> <p>The Lindbladian superoperator \\(\\mathcal{L}\\) is defined by: $$     \\mathcal{L} (\\rho) = -i[H,\\rho] + \\sum_{k=1}^N \\mathcal{D}[L_k] (\\rho), $$</p> <p>where \\(H\\) is the system Hamiltonian, \\(\\{L_k\\}\\) is a set of \\(N\\) jump operators (arbitrary operators) and \\(\\mathcal{D}[L]\\) is the Lindblad dissipation superoperator (see <code>dq.dissipator()</code>).</p> Note <p>This superoperator is also sometimes called Liouvillian.</p> <p> Parameters </p> <ul> <li> H  (array_like of shape (..., n, n))                         \u2013 <p>Hamiltonian.</p> </li> <li> jump_ops  (array_like of shape (N, ..., n, n))                         \u2013 <p>Sequence of jump operators.</p> </li> <li> rho  (array_like of shape (..., n, n))                         \u2013 <p>Density matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Resulting operator (it is not a density matrix).</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; a = dq.destroy(4)\n&gt;&gt;&gt; H = dq.dag(a) @ a\n&gt;&gt;&gt; L = [a, dq.dag(a) @ a]\n&gt;&gt;&gt; rho = dq.fock_dm(4, 1)\n&gt;&gt;&gt; dq.lindbladian(H, L, rho)\nArray([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j, -1.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/norm.html","title":"norm","text":""},{"location":"python_api/utils/quantum_utils/norm.html#dynamiqs.utils.quantum_utils.norm","title":"dq.norm","text":"<pre><code>norm(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the norm of a ket, bra or density matrix.</p> <p>For a ket or a bra, the returned norm is \\(\\sqrt{\\braket{\\psi|\\psi}}\\). For a density matrix, it is \\(\\tr{\\rho}\\).</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., 1, n) or (..., n, n))                         \u2013 <p>Ket, bra or density matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (...)) Real-valued norm of <code>x</code>.</p> <p> Raises </p> <ul> <li> <code> ValueError </code>             \u2013           <p>If <code>x</code> is not a ket, bra or density matrix.</p> </li> </ul> <p> Examples </p> <p>For a ket:</p> <pre><code>&gt;&gt;&gt; psi = dq.fock(4, 0) + dq.fock(4, 1)\n&gt;&gt;&gt; dq.norm(psi)\nArray(1.414, dtype=float32)\n</code></pre> <p>For a density matrix:</p> <pre><code>&gt;&gt;&gt; rho = dq.fock_dm(4, 0) + dq.fock_dm(4, 1) + dq.fock_dm(4, 2)\n&gt;&gt;&gt; dq.norm(rho)\nArray(3., dtype=float32)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/overlap.html","title":"overlap","text":""},{"location":"python_api/utils/quantum_utils/overlap.html#dynamiqs.utils.quantum_utils.overlap","title":"dq.overlap","text":"<pre><code>overlap(x: ArrayLike, y: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the overlap between two quantum states.</p> <p>The overlap is computed</p> <ul> <li>as \\(\\lvert\\braket{\\psi|\\varphi}\\rvert^2\\) if both arguments are kets \\(\\ket\\psi\\)   and \\(\\ket\\varphi\\),</li> <li>as \\(\\lvert\\bra\\psi \\rho \\ket\\psi\\rvert\\) if one argument is a ket \\(\\ket\\psi\\) and   the other is a density matrix \\(\\rho\\),</li> <li>as \\(\\tr{\\rho^\\dag\\sigma}\\) if both arguments are density matrices \\(\\rho\\) and   \\(\\sigma\\).</li> </ul> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., n, n))                         \u2013 <p>Ket or density matrix.</p> </li> <li> y  (array_like of shape (..., n, 1) or (..., n, n))                         \u2013 <p>Ket or density matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (...)) Real-valued overlap.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; fock0 = dq.fock(3, 0)\n&gt;&gt;&gt; dq.overlap(fock0, fock0)\nArray(1., dtype=float32)\n&gt;&gt;&gt; fock01_dm = 0.5 * (dq.fock_dm(3, 0) + dq.fock_dm(3, 1))\n&gt;&gt;&gt; dq.overlap(fock0, fock01_dm)\nArray(0.5, dtype=float32)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/powm.html","title":"powm","text":""},{"location":"python_api/utils/quantum_utils/powm.html#dynamiqs.utils.quantum_utils.powm","title":"dq.powm","text":"<pre><code>powm(x: ArrayLike, n: int) -&gt; Array\n</code></pre> <p>Returns the \\(n\\)-th matrix power of an array.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Square matrix.</p> </li> <li> n            \u2013 <p>Integer exponent.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Matrix power of <code>x</code>.</p> Equivalent JAX syntax <p>This function is equivalent to <code>jnp.linalg.matrix_power(x, n)</code>.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.powm(dq.sigmax(), 2)\nArray([[1.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/proj.html","title":"proj","text":""},{"location":"python_api/utils/quantum_utils/proj.html#dynamiqs.utils.quantum_utils.proj","title":"dq.proj","text":"<pre><code>proj(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the projection operator onto a pure quantum state.</p> <p>The projection operator onto the state \\(\\ket\\psi\\) is defined as \\(P_{\\ket\\psi} = \\ket\\psi\\bra\\psi\\).</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., 1, n))                         \u2013 <p>Ket or bra.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Projection operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psi = dq.fock(3, 0)\n&gt;&gt;&gt; dq.proj(psi)\nArray([[1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/ptrace.html","title":"ptrace","text":""},{"location":"python_api/utils/quantum_utils/ptrace.html#dynamiqs.utils.quantum_utils.ptrace","title":"dq.ptrace","text":"<pre><code>ptrace(x: ArrayLike, keep: int | tuple[int, ...], dims: tuple[int, ...]) -&gt; Array\n</code></pre> <p>Returns the partial trace of a ket, bra or density matrix.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., 1, n) or (..., n, n))                         \u2013 <p>Ket, bra or density matrix of a composite system.</p> </li> <li> keep  (int or tuple of ints)                         \u2013 <p>Dimensions to keep after partial trace.</p> </li> <li> dims  (tuple of ints)                         \u2013 <p>Dimensions of each subsystem in the composite system Hilbert space tensor product.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., m, m)) Density matrix (with <code>m &lt;= n</code>).</p> <p> Raises </p> <ul> <li> <code> ValueError </code>             \u2013           <p>If <code>x</code> is not a ket, bra or density matrix.</p> </li> <li> <code> ValueError </code>             \u2013           <p>If <code>dims</code> does not match the shape of <code>x</code>, or if <code>keep</code> is incompatible with <code>dims</code>.</p> </li> </ul> Note <p>The returned object is always a density matrix, even if the input is a ket or a bra.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psi_abc = dq.tensor(dq.fock(3, 0), dq.fock(4, 2), dq.fock(5, 1))\n&gt;&gt;&gt; psi_abc.shape\n(60, 1)\n&gt;&gt;&gt; rho_a = dq.ptrace(psi_abc, 0, (3, 4, 5))\n&gt;&gt;&gt; rho_a.shape\n(3, 3)\n&gt;&gt;&gt; rho_bc = dq.ptrace(psi_abc, (1, 2), (3, 4, 5))\n&gt;&gt;&gt; rho_bc.shape\n(20, 20)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/sinm.html","title":"sinm","text":""},{"location":"python_api/utils/quantum_utils/sinm.html#dynamiqs.utils.quantum_utils.sinm","title":"dq.sinm","text":"<pre><code>sinm(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the sine of an array.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Square matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Sine of <code>x</code>.</p> Note <p>This function uses <code>jax.scipy.linalg.expm()</code> to compute the sine of a matrix \\(A\\): $$     \\sin(A) = \\frac{e^{iA} - e^{-iA}}{2i} $$</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.sinm(0.5 * jnp.pi * dq.sigmax())\nArray([[0.-0.j, 1.-0.j],\n       [1.-0.j, 0.-0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/tensor.html","title":"tensor","text":""},{"location":"python_api/utils/quantum_utils/tensor.html#dynamiqs.utils.quantum_utils.tensor","title":"dq.tensor","text":"<pre><code>tensor(*args: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the tensor product of multiple kets, bras, density matrices or operators.</p> <p>The returned array shape is:</p> <ul> <li>\\((..., n, 1)\\) with \\(n=\\prod_k n_k\\) if all input arrays are kets with shape   \\((..., n_k, 1)\\),</li> <li>\\((..., 1, n)\\) with \\(n=\\prod_k n_k\\) if all input arrays are bras with shape   \\((..., 1, n_k)\\),</li> <li>\\((..., n, n)\\) with \\(n=\\prod_k n_k\\) if all input arrays are density matrices or   operators with shape \\((..., n_k, n_k)\\).</li> </ul> <p> Parameters </p> <ul> <li> *args  (array_like of shape (..., n_k, 1) or (..., 1, n_k) or (..., n_k, n_k))                         \u2013 <p>Variable length argument list of kets, bras, density matrices or operators.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, 1) or (..., 1, n) or (..., n, n)) Tensor product of the input arrays.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psi = dq.tensor(dq.fock(3, 0), dq.fock(4, 2), dq.fock(5, 1))\n&gt;&gt;&gt; psi.shape\n(60, 1)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/tobra.html","title":"tobra","text":""},{"location":"python_api/utils/quantum_utils/tobra.html#dynamiqs.utils.quantum_utils.tobra","title":"dq.tobra","text":"<pre><code>tobra(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the bra representation of a pure quantum state.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., 1, n))                         \u2013 <p>Ket or bra.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., 1, n)) Bra.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psi = dq.fock(3, 0)  # shape: (3, 1)\n&gt;&gt;&gt; psi\nArray([[1.+0.j],\n       [0.+0.j],\n       [0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.tobra(psi)  # shape: (1, 3)\nArray([[1.-0.j, 0.-0.j, 0.-0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/todm.html","title":"todm","text":""},{"location":"python_api/utils/quantum_utils/todm.html#dynamiqs.utils.quantum_utils.todm","title":"dq.todm","text":"<pre><code>todm(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the density matrix representation of a quantum state.</p> Note <p>This function is an alias of <code>dq.proj()</code>. If <code>x</code> is already a density matrix, it is returned directly.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., 1, n) or (..., n, n))                         \u2013 <p>Ket, bra or density matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Density matrix.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psi = dq.fock(3, 0)  # shape: (3, 1)\n&gt;&gt;&gt; psi\nArray([[1.+0.j],\n       [0.+0.j],\n       [0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.todm(psi)  # shape: (3, 3)\nArray([[1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/toket.html","title":"toket","text":""},{"location":"python_api/utils/quantum_utils/toket.html#dynamiqs.utils.quantum_utils.toket","title":"dq.toket","text":"<pre><code>toket(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the ket representation of a pure quantum state.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., 1, n))                         \u2013 <p>Ket or bra.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, 1)) Ket.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psi = dq.tobra(dq.fock(3, 0))  # shape: (1, 3)\n&gt;&gt;&gt; psi\nArray([[1.-0.j, 0.-0.j, 0.-0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.toket(psi)  # shape: (3, 1)\nArray([[1.+0.j],\n       [0.+0.j],\n       [0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/trace.html","title":"trace","text":""},{"location":"python_api/utils/quantum_utils/trace.html#dynamiqs.utils.quantum_utils.trace","title":"dq.trace","text":"<pre><code>trace(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the trace of an array along its last two dimensions.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Array.</p> </li> </ul> <p> Returns </p> <p>(array of shape (...)) Trace of <code>x</code>.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; x = jnp.ones((3, 3))\n&gt;&gt;&gt; dq.trace(x)\nArray(3., dtype=float32)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/tracemm.html","title":"tracemm","text":""},{"location":"python_api/utils/quantum_utils/tracemm.html#dynamiqs.utils.quantum_utils.tracemm","title":"dq.tracemm","text":"<pre><code>tracemm(x: ArrayLike, y: ArrayLike) -&gt; Array\n</code></pre> <p>Return the trace of a matrix multiplication using a fast implementation.</p> <p>The trace is computed as <code>sum(x * y.T)</code> where <code>*</code> is the element-wise product, instead of <code>trace(x @ y)</code> where <code>@</code> is the matrix product. Indeed, we have:</p> \\[     \\tr{xy} = \\sum_i (xy)_{ii}             = \\sum_{i,j} x_{ij} y_{ji}             = \\sum_{i,j} x_{ij} (y^\\intercal)_{ij}             = \\sum_{i,j} (x * y^\\intercal)_{ij} \\] Note <p>The resulting time complexity for \\(n\\times n\\) matrices is \\(\\mathcal{O}(n^2)\\) instead of \\(\\mathcal{O}(n^3)\\) with the naive formula.</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Array.</p> </li> <li> y  (array_like of shape (..., n, n))                         \u2013 <p>Array.</p> </li> </ul> <p> Returns </p> <p>(array of shape (...)) Trace of <code>x @ y</code>.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; x = jnp.ones((3, 3))\n&gt;&gt;&gt; y = jnp.ones((3, 3))\n&gt;&gt;&gt; dq.tracemm(x, y)\nArray(9., dtype=float32)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/unit.html","title":"unit","text":""},{"location":"python_api/utils/quantum_utils/unit.html#dynamiqs.utils.quantum_utils.unit","title":"dq.unit","text":"<pre><code>unit(x: ArrayLike) -&gt; Array\n</code></pre> <p>Normalize a ket, bra or density matrix to unit norm.</p> <p>The returned object is divided by its norm (see <code>dq.norm()</code>).</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, 1) or (..., 1, n) or (..., n, n))                         \u2013 <p>Ket, bra or density matrix.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, 1) or (..., 1, n) or (..., n, n)) Normalized ket, bra or density matrix.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; psi = dq.fock(4, 0) + dq.fock(4, 1)\n&gt;&gt;&gt; dq.norm(psi)\nArray(1.414, dtype=float32)\n&gt;&gt;&gt; psi = dq.unit(psi)\n&gt;&gt;&gt; dq.norm(psi)\nArray(1., dtype=float32)\n</code></pre>"},{"location":"python_api/utils/quantum_utils/wigner.html","title":"wigner","text":""},{"location":"python_api/utils/quantum_utils/wigner.html#dynamiqs.utils.quantum_utils.wigner","title":"dq.wigner","text":"<pre><code>wigner(\n    state: ArrayLike,\n    xmax: float = 6.0,\n    ymax: float = 6.0,\n    npixels: int = 201,\n    xvec: ArrayLike | None = None,\n    yvec: ArrayLike | None = None,\n    g: float = 2.0,\n) -&gt; tuple[Array, Array, Array]\n</code></pre> <p>Compute the Wigner distribution of a ket or density matrix.</p> <p>The Wigner distribution is computed on a grid of coordinates \\((x, y)\\).</p> <p> Parameters </p> <ul> <li> state  (array_like of shape (..., n, 1) or (..., n, n))                         \u2013 <p>Ket or density matrix.</p> </li> <li> xmax            \u2013 <p>Maximum absolute value of the \\(x\\) coordinate.</p> </li> <li> ymax            \u2013 <p>Maximum absolute value of the \\(y\\) coordinate.</p> </li> <li> npixels            \u2013 <p>Number of pixels in each direction.</p> </li> <li> xvec  (array_like of shape (nxvec,), optional)                         \u2013 <p>\\(x\\) coordinates. If <code>None</code>, defaults to <code>xvec = jnp.linspace(-xmax, xmax, npixels)</code>.</p> </li> <li> yvec  (array_like of shape (nyvec,), optional)                         \u2013 <p>\\(y\\) coordinates. If <code>None</code>, defaults to <code>yvec = jnp.linspace(-ymax, ymax, npixels)</code>.</p> </li> <li> g            \u2013 <p>Scaling factor of Wigner quadratures, such that \\(a = g(x + iy)/2\\).</p> </li> </ul> <p> Returns </p> <p>A tuple <code>(xvec, yvec, w)</code> where</p> <ul> <li>xvec (array of shape (npixels,) or (nxvec,)) -- \\(x\\) coordinates, or     <code>xvec</code> if specified.</li> <li>yvec (array of shape (npixels,) or (nyvec,)) -- \\(y\\) coordinates, or     <code>yvec</code> if specified.</li> <li>w (array of shape (..., npixels, npixels) or (..., nyvec, nxvec)) -- Wigner distribution.</li> </ul>"},{"location":"python_api/utils/states/basis.html","title":"basis","text":""},{"location":"python_api/utils/states/basis.html#dynamiqs.utils.states.basis","title":"dq.basis","text":"<pre><code>basis(dim: int | tuple[int, ...], number: ArrayLike) -&gt; Array\n</code></pre> <p>Alias of <code>dq.fock()</code>.</p>"},{"location":"python_api/utils/states/basis_dm.html","title":"basis_dm","text":""},{"location":"python_api/utils/states/basis_dm.html#dynamiqs.utils.states.basis_dm","title":"dq.basis_dm","text":"<pre><code>basis_dm(dim: int | tuple[int, ...], number: ArrayLike) -&gt; Array\n</code></pre> <p>Alias of <code>dq.fock_dm()</code>.</p>"},{"location":"python_api/utils/states/coherent.html","title":"coherent","text":""},{"location":"python_api/utils/states/coherent.html#dynamiqs.utils.states.coherent","title":"dq.coherent","text":"<pre><code>coherent(dim: int | tuple[int, ...], alpha: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the ket of a coherent state or a tensor product of coherent states.</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Hilbert space dimension of each mode.</p> </li> <li> alpha  (array_like of shape (...) or (..., len(dim)))                         \u2013 <p>Coherent state amplitude for each mode. If <code>dim</code> is a tuple, the last dimension of <code>alpha</code> should match the length of <code>dim</code>.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, 1)) Ket of the coherent state or tensor product of coherent states, with n = prod(dims).</p> <p> Examples </p> <p>Single-mode coherent state \\(\\ket{\\alpha}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent(4, 0.5)\nArray([[0.882+0.j],\n       [0.441+0.j],\n       [0.156+0.j],\n       [0.047+0.j]], dtype=complex64)\n</code></pre> <p>Batched single-mode coherent states \\(\\{\\ket{\\alpha_0}\\!, \\ket{\\alpha_1}\\}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent(4, [0.5, 0.5j])\nArray([[[ 0.882+0.j   ],\n        [ 0.441+0.j   ],\n        [ 0.156+0.j   ],\n        [ 0.047+0.j   ]],\n\n       [[ 0.882+0.j   ],\n        [ 0.   +0.441j],\n        [-0.156+0.j   ],\n        [ 0.   -0.047j]]], dtype=complex64)\n</code></pre> <p>Multi-mode coherent state \\(\\ket{\\alpha}\\otimes\\ket{\\beta}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent((2, 3), (0.5, 0.5j))\nArray([[ 0.775+0.j   ],\n       [ 0.   +0.386j],\n       [-0.146+0.j   ],\n       [ 0.423+0.j   ],\n       [ 0.   +0.211j],\n       [-0.08 +0.j   ]], dtype=complex64)\n</code></pre> <p>Batched multi-mode coherent states \\(\\{\\ket{\\alpha_0}\\otimes\\ket{\\beta_0}\\!, \\ket{\\alpha_1}\\otimes\\ket{\\beta_1}\\}\\):</p> <pre><code>&gt;&gt;&gt; alpha = [(0.5, 0.5j), (0.5j, 0.5)]\n&gt;&gt;&gt; dq.coherent((4, 6), alpha).shape\n(2, 24, 1)\n</code></pre>"},{"location":"python_api/utils/states/coherent_dm.html","title":"coherent_dm","text":""},{"location":"python_api/utils/states/coherent_dm.html#dynamiqs.utils.states.coherent_dm","title":"dq.coherent_dm","text":"<pre><code>coherent_dm(dim: int | tuple[int, ...], alpha: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the density matrix of a coherent state or a tensor product of coherent states.</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Hilbert space dimension of each mode.</p> </li> <li> alpha  (array_like of shape (...) or (..., len(dim)))                         \u2013 <p>Coherent state amplitude for each mode. If <code>dim</code> is a tuple, the last dimension of <code>alpha</code> should match the length of <code>dim</code>.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Density matrix of the coherent state or tensor product of coherent states, with n = prod(dims).</p> <p> Examples </p> <p>Single-mode coherent state \\(\\ket{\\alpha}\\bra{\\alpha}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent_dm(4, 0.5)\nArray([[0.779+0.j, 0.389+0.j, 0.137+0.j, 0.042+0.j],\n       [0.389+0.j, 0.195+0.j, 0.069+0.j, 0.021+0.j],\n       [0.137+0.j, 0.069+0.j, 0.024+0.j, 0.007+0.j],\n       [0.042+0.j, 0.021+0.j, 0.007+0.j, 0.002+0.j]], dtype=complex64)\n</code></pre> <p>Batched single-mode coherent states \\(\\{\\ket{\\alpha_0}\\bra{\\alpha_0}\\!, \\ket{\\alpha_1}\\bra{\\alpha_1}\\}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent_dm(4, [0.5, 0.5j]).shape\n(2, 4, 4)\n</code></pre> <p>Multi-mode coherent state \\(\\ket{\\alpha}\\bra{\\alpha}\\otimes\\ket{\\beta}\\bra{\\beta}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent_dm((2, 3), (0.5, 0.5j)).shape\n(6, 6)\n</code></pre> <p>Batched multi-mode coherent states \\(\\{\\ket{\\alpha_0}\\bra{\\alpha_0}\\otimes\\ket{\\beta_0}\\bra{\\beta_0}\\!, \\ket{\\alpha_1}\\bra{\\alpha_1}\\otimes\\ket{\\beta_1}\\bra{\\beta_1}\\}\\):</p> <pre><code>&gt;&gt;&gt; alpha = [(0.5, 0.5j), (0.5j, 0.5)]\n&gt;&gt;&gt; dq.coherent_dm((4, 6), alpha).shape\n(2, 24, 24)\n</code></pre>"},{"location":"python_api/utils/states/excited.html","title":"excited","text":""},{"location":"python_api/utils/states/excited.html#dynamiqs.utils.states.excited","title":"dq.excited","text":"<pre><code>excited() -&gt; Array\n</code></pre> <p>Returns the eigenvector with eigenvalue +1 of the Pauli \\(\\sigma_z\\) operator.</p> <p>It is defined by \\(\\ket{e} = \\begin{pmatrix}1\\\\0\\end{pmatrix}\\).</p> Note <p>This function is named <code>excited</code> because \\(\\ket{e}\\) is the higher energy state of a two-level-system with Hamiltonian \\(H=\\omega \\sigma_z\\).</p> <p> Returns </p> <p>(array of shape (2, 1)) Ket \\(\\ket{e}\\).</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.excited()\nArray([[1.+0.j],\n       [0.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/states/fock.html","title":"fock","text":""},{"location":"python_api/utils/states/fock.html#dynamiqs.utils.states.fock","title":"dq.fock","text":"<pre><code>fock(dim: int | tuple[int, ...], number: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the ket of a Fock state or a tensor product of Fock states.</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Hilbert space dimension of each mode.</p> </li> <li> number  (array_like of shape (...) or (..., len(dim)))                         \u2013 <p>Fock state number for each mode, of integer type. If <code>dim</code> is a tuple, the last dimension of <code>number</code> should match the length of <code>dim</code>.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, 1)) Ket of the Fock state or tensor product of Fock states, with n = prod(dims).</p> <p> Examples </p> <p>Single-mode Fock state \\(\\ket{1}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock(3, 1)\nArray([[0.+0.j],\n       [1.+0.j],\n       [0.+0.j]], dtype=complex64)\n</code></pre> <p>Batched single-mode Fock states \\(\\{\\ket{0}\\!, \\ket{1}\\!, \\ket{2}\\}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock(3, [0, 1, 2])\nArray([[[1.+0.j],\n        [0.+0.j],\n        [0.+0.j]],\n\n       [[0.+0.j],\n        [1.+0.j],\n        [0.+0.j]],\n\n       [[0.+0.j],\n        [0.+0.j],\n        [1.+0.j]]], dtype=complex64)\n</code></pre> <p>Multi-mode Fock state \\(\\ket{1,0}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock((3, 2), (1, 0))\nArray([[0.+0.j],\n       [0.+0.j],\n       [1.+0.j],\n       [0.+0.j],\n       [0.+0.j],\n       [0.+0.j]], dtype=complex64)\n</code></pre> <p>Batched multi-mode Fock states \\(\\{\\ket{0,0}\\!, \\ket{0,1}\\!, \\ket{1,1}\\!, \\ket{2,0}\\}\\):</p> <pre><code>&gt;&gt;&gt; number = [(0, 0), (0, 1), (1, 1), (2, 0)]\n&gt;&gt;&gt; dq.fock((3, 2), number).shape\n(4, 6, 1)\n</code></pre>"},{"location":"python_api/utils/states/fock_dm.html","title":"fock_dm","text":""},{"location":"python_api/utils/states/fock_dm.html#dynamiqs.utils.states.fock_dm","title":"dq.fock_dm","text":"<pre><code>fock_dm(dim: int | tuple[int, ...], number: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the density matrix of a Fock state or a tensor product of Fock states.</p> <p> Parameters </p> <ul> <li> dim            \u2013 <p>Hilbert space dimension of each mode.</p> </li> <li> number  (array_like of shape (...) or (..., len(dim)))                         \u2013 <p>Fock state number for each mode, of integer type. If <code>dim</code> is a tuple, the last dimension of <code>number</code> should match the length of <code>dim</code>.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Density matrix of the Fock state or tensor product of Fock states, with n = prod(dims).</p> <p> Examples </p> <p>Single-mode Fock state \\(\\ket{1}\\bra{1}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock_dm(3, 1)\nArray([[0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre> <p>Batched single-mode Fock states \\(\\{\\ket{0}\\bra{0}\\!, \\ket{1}\\bra{1}\\!, \\ket{2}\\bra{2}\\}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock_dm(3, [0, 1, 2])\nArray([[[1.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j]],\n\n       [[0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 1.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j]],\n\n       [[0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 1.+0.j]]], dtype=complex64)\n</code></pre> <p>Multi-mode Fock state \\(\\ket{1,0}\\bra{1,0}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock_dm((3, 2), (1, 0))\nArray([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]], dtype=complex64)\n</code></pre> <p>Batched multi-mode Fock states \\(\\{\\ket{0,0}\\bra{0,0}\\!, \\ket{0,1}\\bra{0,1}\\!, \\ket{1,1}\\bra{1,1}\\!, \\ket{2,0}\\bra{2,0}\\}\\):</p> <pre><code>&gt;&gt;&gt; number = [(0, 0), (0, 1), (1, 1), (2, 0)]\n&gt;&gt;&gt; dq.fock_dm((3, 2), number).shape\n(4, 6, 6)\n</code></pre>"},{"location":"python_api/utils/states/ground.html","title":"ground","text":""},{"location":"python_api/utils/states/ground.html#dynamiqs.utils.states.ground","title":"dq.ground","text":"<pre><code>ground() -&gt; Array\n</code></pre> <p>Returns the eigenvector with eigenvalue -1 of the Pauli \\(\\sigma_z\\) operator.</p> <p>It is defined by \\(\\ket{g} = \\begin{pmatrix}0\\\\1\\end{pmatrix}\\).</p> Note <p>This function is named <code>ground</code> because \\(\\ket{g}\\) is the lower energy state of a two-level system with Hamiltonian \\(H=\\omega \\sigma_z\\).</p> <p> Returns </p> <p>(array of shape (2, 1)) Ket \\(\\ket{g}\\).</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.ground()\nArray([[0.+0.j],\n       [1.+0.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/vectorization/operator_to_vector.html","title":"operator_to_vector","text":""},{"location":"python_api/utils/vectorization/operator_to_vector.html#dynamiqs.utils.vectorization.operator_to_vector","title":"dq.operator_to_vector","text":"<pre><code>operator_to_vector(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the vectorized version of an operator.</p> <p>The vectorized column vector \\(\\kett{A}\\) (shape \\(n^2\\times 1\\)) is obtained by stacking the columns of the matrix \\(A\\) (shape \\(n\\times n\\)) on top of one another: $$     A = \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix}     \\to     \\kett{A} = \\begin{pmatrix} a \\\\ c \\\\ b \\\\ d \\end{pmatrix}. $$</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Operator.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n^2, 1)) Vectorized operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; A = jnp.array([[1 + 1j, 2 + 2j], [3 + 3j, 4 + 4j]])\n&gt;&gt;&gt; A\nArray([[1.+1.j, 2.+2.j],\n       [3.+3.j, 4.+4.j]], dtype=complex64)\n&gt;&gt;&gt; dq.operator_to_vector(A)\nArray([[1.+1.j],\n       [3.+3.j],\n       [2.+2.j],\n       [4.+4.j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/vectorization/sdissipator.html","title":"sdissipator","text":""},{"location":"python_api/utils/vectorization/sdissipator.html#dynamiqs.utils.vectorization.sdissipator","title":"dq.sdissipator","text":"<pre><code>sdissipator(L: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the Lindblad dissipation superoperator (in matrix form).</p> <p>The dissipation superoperator \\(\\mathcal{D}[L]\\) is defined by: $$     \\mathcal{D}[L] (\\rho) = L\\rho L^\\dag - \\frac{1}{2}L^\\dag L \\rho     - \\frac{1}{2}\\rho L^\\dag L. $$</p> <p>The vectorized form of this superoperator is: $$     L^* \\otimes L     - \\frac{1}{2} (I_n \\otimes L^\\dag L)     - \\frac{1}{2} (L^\\mathrm{T} L^* \\otimes I_n). $$</p> <p> Parameters </p> <ul> <li> L  (array_like of shape (..., n, n))                         \u2013 <p>Jump operator.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n^2, n^2)) Dissipation superoperator.</p>"},{"location":"python_api/utils/vectorization/slindbladian.html","title":"slindbladian","text":""},{"location":"python_api/utils/vectorization/slindbladian.html#dynamiqs.utils.vectorization.slindbladian","title":"dq.slindbladian","text":"<pre><code>slindbladian(H: ArrayLike, jump_ops: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the Lindbladian superoperator (in matrix form).</p> <p>The Lindbladian superoperator \\(\\mathcal{L}\\) is defined by: $$     \\mathcal{L} (\\rho) = -i[H,\\rho] + \\sum_{k=1}^N \\mathcal{D}[L_k] (\\rho), $$</p> <p>where \\(H\\) is the system Hamiltonian, \\(\\{L_k\\}\\) is a set of \\(N\\) jump operators (arbitrary operators) and \\(\\mathcal{D}[L]\\) is the Lindblad dissipation superoperator (see <code>dq.sdissipator()</code>).</p> <p>The vectorized form of this superoperator is: $$     -i (I_n \\otimes H) + i (H^\\mathrm{T} \\otimes I_n) + \\sum_{k=1}^N \\left(         L_k^* \\otimes L_k         - \\frac{1}{2} (I_n \\otimes L_k^\\dag L_k)         - \\frac{1}{2} (L_k^\\mathrm{T} L_k^* \\otimes I_n)     \\right). $$</p> Note <p>This superoperator is also sometimes called Liouvillian.</p> See also <ul> <li><code>dq.lindbladian</code>: apply the Lindbladian only through matrix-matrix products.</li> </ul> <p> Parameters </p> <ul> <li> H  (array_like of shape (..., n, n))                         \u2013 <p>Hamiltonian.</p> </li> <li> jump_ops  (array_like of shape (N, ..., n, n))                         \u2013 <p>Sequence of jump operators.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n^2, n^2)) Lindbladian superoperator.</p>"},{"location":"python_api/utils/vectorization/spost.html","title":"spost","text":""},{"location":"python_api/utils/vectorization/spost.html#dynamiqs.utils.vectorization.spost","title":"dq.spost","text":"<pre><code>spost(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the superoperator formed from post-multiplication by an operator.</p> <p>Post-multiplication by matrix \\(A\\) is defined by the superoperator \\(A^\\mathrm{T} \\otimes I_n\\) in vectorized form: $$     XA \\to (A^\\mathrm{T} \\otimes I_n) \\kett{X}. $$</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Operator.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n^2, n^2)) Post-multiplication superoperator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.spost(dq.destroy(3)).shape\n(9, 9)\n</code></pre>"},{"location":"python_api/utils/vectorization/spre.html","title":"spre","text":""},{"location":"python_api/utils/vectorization/spre.html#dynamiqs.utils.vectorization.spre","title":"dq.spre","text":"<pre><code>spre(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the superoperator formed from pre-multiplication by an operator.</p> <p>Pre-multiplication by matrix \\(A\\) is defined by the superoperator \\(I_n \\otimes A\\) in vectorized form: $$     AX \\to (I_n \\otimes A) \\kett{X}. $$</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Operator.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n^2, n^2)) Pre-multiplication superoperator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.spre(dq.destroy(3)).shape\n(9, 9)\n</code></pre>"},{"location":"python_api/utils/vectorization/sprepost.html","title":"sprepost","text":""},{"location":"python_api/utils/vectorization/sprepost.html#dynamiqs.utils.vectorization.sprepost","title":"dq.sprepost","text":"<pre><code>sprepost(x: ArrayLike, y: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the superoperator formed from pre- and post-multiplication by operators.</p> <p>Pre-multiplication by matrix \\(A\\) and post-multiplication by matrix \\(B\\) is defined by the superoperator \\(B^\\mathrm{T} \\otimes A\\) in vectorized form: $$     AXB \\to (B^\\mathrm{T} \\otimes A) \\kett{X}. $$</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n, n))                         \u2013 <p>Operator for pre-multiplication.</p> </li> <li> y  (array_like of shape (..., n, n))                         \u2013 <p>Operator for post-multiplication.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n^2, n^2)) Pre- and post-multiplication superoperator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; dq.sprepost(dq.destroy(3), dq.create(3)).shape\n(9, 9)\n</code></pre>"},{"location":"python_api/utils/vectorization/vector_to_operator.html","title":"vector_to_operator","text":""},{"location":"python_api/utils/vectorization/vector_to_operator.html#dynamiqs.utils.vectorization.vector_to_operator","title":"dq.vector_to_operator","text":"<pre><code>vector_to_operator(x: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the operator version of a vectorized operator.</p> <p>The matrix \\(A\\) (shape \\(n\\times n\\)) is obtained by stacking horizontally next to each other each group of \\(n\\) elements of the vectorized column vector \\(\\kett{A}\\) (shape \\(n^2\\times 1\\)): $$     \\kett{A} = \\begin{pmatrix} a \\\\ b \\\\ c \\\\ d \\end{pmatrix}     \\to     A = \\begin{pmatrix} a &amp; c \\\\ b &amp; d \\end{pmatrix}. $$</p> <p> Parameters </p> <ul> <li> x  (array_like of shape (..., n^2, 1))                         \u2013 <p>Vectorized operator.</p> </li> </ul> <p> Returns </p> <p>(array of shape (..., n, n)) Operator.</p> <p> Examples </p> <pre><code>&gt;&gt;&gt; Avec = jnp.array([[1 + 1j], [2 + 2j], [3 + 3j], [4 + 4j]])\n&gt;&gt;&gt; Avec\nArray([[1.+1.j],\n       [2.+2.j],\n       [3.+3.j],\n       [4.+4.j]], dtype=complex64)\n&gt;&gt;&gt; dq.vector_to_operator(Avec)\nArray([[1.+1.j, 3.+3.j],\n       [2.+2.j, 4.+4.j]], dtype=complex64)\n</code></pre>"}]}